{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"cau-repl Extend Java programs with Groovy at runtime. Add an interactive SSH-based REPL to any JVM and tweak it with your own custom Groovy classes. The cau-repl comes bundled with an additional MyCoRe module for easy integration with your document repository. Disclaimer This project is in a very early stage: expect bugs. As of today, testing was exclusively on Linux. While the code is intended to be OS-agnostic, there will certainly be issues if you run it on Windows (it might run fine on the WSL, though). Pull requests for compatibility are welcome! Testing of the MyCoRe plugin was until now conducted only in a Tomcat environment. Features cau-repl enables you to: Connect to your JVMs via SSH and run Groovy commands in them. You can use all the classes interactively. Load any Maven artifact into the REPL at runtime and use it just in your session Start long-running batch jobs from the SSH console that persist after you disconnect, monitor their status and easily retry failed steps. Job inputs can be processed in parallel, with automatic tuning to determine the number of workers that maximize throughput. Extend any Java program with your own Groovy classes, e.g. for dependency injection. Automatically run your own Groovy code each time the application is started. (experimental) Patch classes of any Java program replacing their methods with your own Groovy code, even if the methods are private. All changes are applied ad-hoc each time the application starts without altering its installation. Use interactive breakpoints that transfer control to the SSH console under certain circumstances. (very experimental) change the code of methods at runtime, even if those methods are called from Java code. cau-repl can be built as a MyCoRe plugin that enables better integration: Simple installation: just put one .jar in your lib/ directory and enable the REPL in your .properties Extend your repository with your own EventHandlers, CronJobs, etc. - no need to create a plugin, set up a full development environment or (re-)compile anything: just drop a single .groovy file in the right directory and the class will be available in MyCoRe. Numerous helper functions that make interacting with your repository from the REPL easy: SOLR searches Retrieving documents and their XML via XPath Displaying, changing (by XSLT or manually), saving XML Generating diffs between updated XML and the original before saving Easy MyCoRe session management: run any command as any user, with automatic transactions The REPL's Job system is integrated with MyCoRe's, so jobs started from the REPL can also be managed via the webinterface. MyCoRe's own CLI commands are also available and can be used from the REPL. Requirements Java 17 or 21 (other versions > 17 may or may not work) Maven vim or any other console text editor that can run without a tty (optional: only if you want to edit files within the SSH session) MyCoRe 2022.06 (optional: only if you would like to use the MyCoRe plugin; other versions may or may not work) License cau-repl is MIT licensed. Designated portions of it were imported from other projects and are Apache 2.0 licensed. The optional MyCoRe support module is GPL 3.0 licensed. It is not included in the build by default. The documentation contains instructions on building a version with the MyCoRe-specific helpers enabled (the -gpl build). You can use this build under the terms of the GPL 3.0. In this sense, cau-repl is dual-licensed under either the MIT or GPL 3.0 license. See the bundled LICENSE.txt file and the SPDX identifier of each source file for details. Quickstart cau-repl can be built in two flavors: as a MyCoRe plugin, or as a generic Java agent from all kinds of java applications. Choose the quickstart instructions that apply to your use-case. For universal use, built without GPL code mvn clean package java -javaagent:target/cau-repl-X.Y.Z-fatjar-mit.jar -jar /path/to/your/application.jar # a message like \"REPL: Session Password auto-generated: XXXXXXXXXX\" should be printed to the terminal # you may now login with any username and the password that was just printed ssh \"ssh://localhost:8512\" If you don't have a Java target application available and just want to see the REPL in action, you can also start the agent directly without a target: java -jar target/cau-repl-X.Y.Z-fatjar-mit.jar Things to try Your commands run in the target application's JVM. Try listing all threads: groovy:000> Thread.allStackTraces.entrySet().collect{ \"${it.key} -> ${it.value ? it.value[0] : ''}\" } ===> [Thread[HikariPool-1 housekeeper,5,main] -> java.base@17.0.8/jdk.internal.misc.Unsafe.park(Native Method), ... Now import a class of your target and start interacting groovy:000> import foo.bar.SomeClass groovy:000> SomeClass.someStaticMethod() groovy:000> x = new SomeClass() ... Can't find the classes you are looking for? Then you should configure cau-repl to use the same ClassLoader as your target. Want to define your own classes? Then you might have to configure cau-repl's ClassLoader use as well. Consult the installation manual for details. For use in MyCoRe, built with GPL code mvn -P gpl clean package cp target/cau-repl-X.Y.Z-fatjar-gpl.jar /path/to/mycore/lib echo \"CAU.REPL.Enabled=true\" >> /path/to/mycore/mycore.properties # now (re-)start your servlet container # a message like \"REPLLog: REPL listening on 127.0.0.1:8512\" should be logged # you may now login with the MyCoRe administrator password ssh \"ssh://administrator@localhost:8512\" Things to try Your commands run directly in MyCoRe's JVM. Try pinging a Solr core: groovy:000> MCRSolrClientFactory.mainSolrClient.ping() ===> {responseHeader={zkConnected=null,status=0,QTime=13,params={q={!lucene}*:*,distrib=false,df=allMeta,facet.field=mods.genre,echoParams=all,fl=*,score,sort=score desc, mods.dateIssued desc,facet.mincount=1,rows=20,wt=javabin,version=2,facet=true,rid=-26}},status=OK} Numerous helper functions are available. Go retrieve a document and inspect it: groovy:000> doc = mcrxml(\"mods\", filter=\".[//mods:title='SOMETITLEHERE']\")[0] ===> [Document: No DOCTYPE declaration, Root is [Element: <mycoreobject/>]] groovy:000> doc() ===> <mycoreobject xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchema Location=\"datamodel-mods.xsd\" ID=\"fdr_mods_00000299\" version=\"2022.06.3-SNAPSHOT\" label=\"fdr_mods_00000299\"> ...","title":"About"},{"location":"#cau-repl","text":"Extend Java programs with Groovy at runtime. Add an interactive SSH-based REPL to any JVM and tweak it with your own custom Groovy classes. The cau-repl comes bundled with an additional MyCoRe module for easy integration with your document repository.","title":"cau-repl"},{"location":"#disclaimer","text":"This project is in a very early stage: expect bugs. As of today, testing was exclusively on Linux. While the code is intended to be OS-agnostic, there will certainly be issues if you run it on Windows (it might run fine on the WSL, though). Pull requests for compatibility are welcome! Testing of the MyCoRe plugin was until now conducted only in a Tomcat environment.","title":"Disclaimer"},{"location":"#features","text":"cau-repl enables you to: Connect to your JVMs via SSH and run Groovy commands in them. You can use all the classes interactively. Load any Maven artifact into the REPL at runtime and use it just in your session Start long-running batch jobs from the SSH console that persist after you disconnect, monitor their status and easily retry failed steps. Job inputs can be processed in parallel, with automatic tuning to determine the number of workers that maximize throughput. Extend any Java program with your own Groovy classes, e.g. for dependency injection. Automatically run your own Groovy code each time the application is started. (experimental) Patch classes of any Java program replacing their methods with your own Groovy code, even if the methods are private. All changes are applied ad-hoc each time the application starts without altering its installation. Use interactive breakpoints that transfer control to the SSH console under certain circumstances. (very experimental) change the code of methods at runtime, even if those methods are called from Java code. cau-repl can be built as a MyCoRe plugin that enables better integration: Simple installation: just put one .jar in your lib/ directory and enable the REPL in your .properties Extend your repository with your own EventHandlers, CronJobs, etc. - no need to create a plugin, set up a full development environment or (re-)compile anything: just drop a single .groovy file in the right directory and the class will be available in MyCoRe. Numerous helper functions that make interacting with your repository from the REPL easy: SOLR searches Retrieving documents and their XML via XPath Displaying, changing (by XSLT or manually), saving XML Generating diffs between updated XML and the original before saving Easy MyCoRe session management: run any command as any user, with automatic transactions The REPL's Job system is integrated with MyCoRe's, so jobs started from the REPL can also be managed via the webinterface. MyCoRe's own CLI commands are also available and can be used from the REPL.","title":"Features"},{"location":"#requirements","text":"Java 17 or 21 (other versions > 17 may or may not work) Maven vim or any other console text editor that can run without a tty (optional: only if you want to edit files within the SSH session) MyCoRe 2022.06 (optional: only if you would like to use the MyCoRe plugin; other versions may or may not work)","title":"Requirements"},{"location":"#license","text":"cau-repl is MIT licensed. Designated portions of it were imported from other projects and are Apache 2.0 licensed. The optional MyCoRe support module is GPL 3.0 licensed. It is not included in the build by default. The documentation contains instructions on building a version with the MyCoRe-specific helpers enabled (the -gpl build). You can use this build under the terms of the GPL 3.0. In this sense, cau-repl is dual-licensed under either the MIT or GPL 3.0 license. See the bundled LICENSE.txt file and the SPDX identifier of each source file for details.","title":"License"},{"location":"#quickstart","text":"cau-repl can be built in two flavors: as a MyCoRe plugin, or as a generic Java agent from all kinds of java applications. Choose the quickstart instructions that apply to your use-case.","title":"Quickstart"},{"location":"#for-universal-use-built-without-gpl-code","text":"mvn clean package java -javaagent:target/cau-repl-X.Y.Z-fatjar-mit.jar -jar /path/to/your/application.jar # a message like \"REPL: Session Password auto-generated: XXXXXXXXXX\" should be printed to the terminal # you may now login with any username and the password that was just printed ssh \"ssh://localhost:8512\" If you don't have a Java target application available and just want to see the REPL in action, you can also start the agent directly without a target: java -jar target/cau-repl-X.Y.Z-fatjar-mit.jar","title":"For universal use, built without GPL code"},{"location":"#things-to-try","text":"Your commands run in the target application's JVM. Try listing all threads: groovy:000> Thread.allStackTraces.entrySet().collect{ \"${it.key} -> ${it.value ? it.value[0] : ''}\" } ===> [Thread[HikariPool-1 housekeeper,5,main] -> java.base@17.0.8/jdk.internal.misc.Unsafe.park(Native Method), ... Now import a class of your target and start interacting groovy:000> import foo.bar.SomeClass groovy:000> SomeClass.someStaticMethod() groovy:000> x = new SomeClass() ... Can't find the classes you are looking for? Then you should configure cau-repl to use the same ClassLoader as your target. Want to define your own classes? Then you might have to configure cau-repl's ClassLoader use as well. Consult the installation manual for details.","title":"Things to try"},{"location":"#for-use-in-mycore-built-with-gpl-code","text":"mvn -P gpl clean package cp target/cau-repl-X.Y.Z-fatjar-gpl.jar /path/to/mycore/lib echo \"CAU.REPL.Enabled=true\" >> /path/to/mycore/mycore.properties # now (re-)start your servlet container # a message like \"REPLLog: REPL listening on 127.0.0.1:8512\" should be logged # you may now login with the MyCoRe administrator password ssh \"ssh://administrator@localhost:8512\"","title":"For use in MyCoRe, built with GPL code"},{"location":"#things-to-try_1","text":"Your commands run directly in MyCoRe's JVM. Try pinging a Solr core: groovy:000> MCRSolrClientFactory.mainSolrClient.ping() ===> {responseHeader={zkConnected=null,status=0,QTime=13,params={q={!lucene}*:*,distrib=false,df=allMeta,facet.field=mods.genre,echoParams=all,fl=*,score,sort=score desc, mods.dateIssued desc,facet.mincount=1,rows=20,wt=javabin,version=2,facet=true,rid=-26}},status=OK} Numerous helper functions are available. Go retrieve a document and inspect it: groovy:000> doc = mcrxml(\"mods\", filter=\".[//mods:title='SOMETITLEHERE']\")[0] ===> [Document: No DOCTYPE declaration, Root is [Element: <mycoreobject/>]] groovy:000> doc() ===> <mycoreobject xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchema Location=\"datamodel-mods.xsd\" ID=\"fdr_mods_00000299\" version=\"2022.06.3-SNAPSHOT\" label=\"fdr_mods_00000299\"> ...","title":"Things to try"},{"location":"configuration/","text":"Configuration If you use the cau-repl Java agent, you can configure it via Java system properties. Set them e.g. from the command line, as in java -DCAU.REPL.Enabled=true , or by Java's @ parameter syntax to read them from a file. Users of the MyCoRe plugin should use their mycore.properties file and only resort to system properties to configure the agent in support mode if they enabled the early-loading mechanism. System Properties for the Universal Java Agent Property Default Description CAU.Groovy.ClassPath <Java System Classpath> The classpath to use when compiling your .groocy sources. CAU.Groovy.DeferMetaClasses false Only needed in special cases. Do not add Groovy MetaClasses to compiled .groovy files from the agent. This has the effect of leaving your classes uninitialized so you can manually initialize them in a specific order later on. You can use the GroovySourceDirectory.addDynamizedMetaClass() to add the MetaClasses later on and force class initialization. If you set this to true and do not invoke this method for your classes, some features of cau-repl (e.g. @Dynamize ) will be broken. CAU.Groovy.ReorderSources true Set to false to disable the logic that determines the proper compilation order for your .groovy sources. Disabling this setting will break compilation unless your classes are trivial, so you should only disable it for debugging. CAU.Groovy.SourceDirs A comma-separated list of directories. All .groovy files in all subdirectories will be compiled into the JVM on startup. CAU.Groovy.UseSystemClassLoader false Set this to true to use the system-default ClassLoader and make your classes available outside of the REPL. See the Installation instructions for further details if you enable this. CAU.JavaAgent.AutoExec A Groovy command that will be executed on startup directly after your sources have been compiled and before starting the REPL. CAU.JavaAgent.ClassPath JARs that the agent will add to the system classpath, e.g. to specify the location of the cau-repl fat jar if it is off-path. CAU.JavaAgent.SupportMode Set this to true when you use the agent in conjunction with the MyCoRe plugin CAU.JavaAgent.Triggers Loads the REPL in the same classloader as this package or class (e.g. org/example/ ). CAU.REPL.EditorSSH /usr/bin/vim --not-a-term The editor to use for interactive file editing within the SSH environment. Must be able to run without a TTY. CAU.REPL.Enabled true If set, the REPL will listen for SSH connections. CAU.REPL.Log.Internal If set to file , redirects cau-repl's internal log messages from STDERR (or Log4J if installed) to the repl.log file in its work dir. If set to stderr , messages are always redirected to STDERR (never to Log4J). CAU.REPL.Log.Trace false Enable very fine grained logging of the REPL's internals. Only use this for debugging. These types of messages will then be written to repl.log . Set CAU.REPL.Log.Internal = stderr to also see them at the console. CAU.REPL.MaxBreakpoints 20 Maximum number of breakpoints that can remain uncontinued at a given time. Further triggered breakpoints will be dropped. CAU.REPL.SSH.ListenAddr 127.0.0.1 The address that the REPL should listen on for SSH connections. Protect outside access to this port as you would protect a normal SSH port with shell access: users who connect can execute arbitrary commands. CAU.REPL.SSH.ListenPort 8512 The port that the REPL should listen on for SSH connections. CAU.REPL.SSH.Password The password that grants access to the REPL via SSH. Pass this from a file via Java's @ parameter syntax. Otherwise, it will be visible in the process list for all local users. Even then, your application might dump the value of all properties into a debug log, so you should generally use the CAU.REPL.SSH.PasswordCommand property instead. CAU.REPL.SSH.PasswordCommand A command that returns the password to be used for the REPL's SSH on STDOUT. Mutually exclusive with CAU.REPL.SSH.Password. CAU.REPL.SSH.Timeout 43200 (12h) Disconnect SSH connections after they have been idle for this many seconds. CAU.REPL.WorkDir ./cau-repl The directory in which the REPL will store its state. MyCoRe Plugin Properties Property Default Description CAU.REPL.Groovy.ReorderSources true Set to false to disable the logic that determines the proper compilation order for your .groovy sources. Disabling this setting will break compilation unless your classes are trivial, so you should only disable it for debugging. CAU.Groovy.SourceDirs.1, CAU.Groovy.SourceDirs.2, ... Root directories for your Groovy sources. All .groovy files in all their subdirectories will be compiled into the JVM on startup. CAU.REPL.Groovy.Startup.Scripts.1 CAU.REPL.Groovy.Startup.Scripts.2, ... Each Groovy script file you list here will be executed in the REPL whenever you connect to it as if you had typed it there. CAU.REPL.Groovy.Startup.Commands.1 CAU.REPL.Groovy.Startup.Commands.2, ... Each Groovy command you list here will be executed in the REPL whenever you connect to it as if you had typed it there. CAU.REPL.EditorSSH /usr/bin/vim --not-a-term The editor to use for interactive file editing within the SSH environment. Must be able to run without a TTY. CAU.REPL.Enabled false If set, the REPL will listen for SSH connections. CAU.REPL.Log.Trace false Enable very fine grained logging of the REPL's internals. Only use this for debugging. CAU.REPL.MaxBreakpoints 20 Maximum number of breakpoints that can remain uncontinued at a given time. Further triggered breakpoints will be dropped. CAU.REPL.SSH.ListenAddr 127.0.0.1 The address that the REPL should listen on for SSH connections. Protect outside access to this port as you would protect a normal SSH port with shell access: users who connect can execute arbitrary commands. CAU.REPL.SSH.ListenPort 8512 The port that the REPL should listen on for SSH connections. CAU.REPL.SSH.TimeoutSeconds 43200 (12h) Disconnect SSH connections after they have been idle for this many seconds.","title":"Configuration"},{"location":"configuration/#configuration","text":"If you use the cau-repl Java agent, you can configure it via Java system properties. Set them e.g. from the command line, as in java -DCAU.REPL.Enabled=true , or by Java's @ parameter syntax to read them from a file. Users of the MyCoRe plugin should use their mycore.properties file and only resort to system properties to configure the agent in support mode if they enabled the early-loading mechanism.","title":"Configuration"},{"location":"configuration/#system-properties-for-the-universal-java-agent","text":"Property Default Description CAU.Groovy.ClassPath <Java System Classpath> The classpath to use when compiling your .groocy sources. CAU.Groovy.DeferMetaClasses false Only needed in special cases. Do not add Groovy MetaClasses to compiled .groovy files from the agent. This has the effect of leaving your classes uninitialized so you can manually initialize them in a specific order later on. You can use the GroovySourceDirectory.addDynamizedMetaClass() to add the MetaClasses later on and force class initialization. If you set this to true and do not invoke this method for your classes, some features of cau-repl (e.g. @Dynamize ) will be broken. CAU.Groovy.ReorderSources true Set to false to disable the logic that determines the proper compilation order for your .groovy sources. Disabling this setting will break compilation unless your classes are trivial, so you should only disable it for debugging. CAU.Groovy.SourceDirs A comma-separated list of directories. All .groovy files in all subdirectories will be compiled into the JVM on startup. CAU.Groovy.UseSystemClassLoader false Set this to true to use the system-default ClassLoader and make your classes available outside of the REPL. See the Installation instructions for further details if you enable this. CAU.JavaAgent.AutoExec A Groovy command that will be executed on startup directly after your sources have been compiled and before starting the REPL. CAU.JavaAgent.ClassPath JARs that the agent will add to the system classpath, e.g. to specify the location of the cau-repl fat jar if it is off-path. CAU.JavaAgent.SupportMode Set this to true when you use the agent in conjunction with the MyCoRe plugin CAU.JavaAgent.Triggers Loads the REPL in the same classloader as this package or class (e.g. org/example/ ). CAU.REPL.EditorSSH /usr/bin/vim --not-a-term The editor to use for interactive file editing within the SSH environment. Must be able to run without a TTY. CAU.REPL.Enabled true If set, the REPL will listen for SSH connections. CAU.REPL.Log.Internal If set to file , redirects cau-repl's internal log messages from STDERR (or Log4J if installed) to the repl.log file in its work dir. If set to stderr , messages are always redirected to STDERR (never to Log4J). CAU.REPL.Log.Trace false Enable very fine grained logging of the REPL's internals. Only use this for debugging. These types of messages will then be written to repl.log . Set CAU.REPL.Log.Internal = stderr to also see them at the console. CAU.REPL.MaxBreakpoints 20 Maximum number of breakpoints that can remain uncontinued at a given time. Further triggered breakpoints will be dropped. CAU.REPL.SSH.ListenAddr 127.0.0.1 The address that the REPL should listen on for SSH connections. Protect outside access to this port as you would protect a normal SSH port with shell access: users who connect can execute arbitrary commands. CAU.REPL.SSH.ListenPort 8512 The port that the REPL should listen on for SSH connections. CAU.REPL.SSH.Password The password that grants access to the REPL via SSH. Pass this from a file via Java's @ parameter syntax. Otherwise, it will be visible in the process list for all local users. Even then, your application might dump the value of all properties into a debug log, so you should generally use the CAU.REPL.SSH.PasswordCommand property instead. CAU.REPL.SSH.PasswordCommand A command that returns the password to be used for the REPL's SSH on STDOUT. Mutually exclusive with CAU.REPL.SSH.Password. CAU.REPL.SSH.Timeout 43200 (12h) Disconnect SSH connections after they have been idle for this many seconds. CAU.REPL.WorkDir ./cau-repl The directory in which the REPL will store its state.","title":"System Properties for the Universal Java Agent"},{"location":"configuration/#mycore-plugin-properties","text":"Property Default Description CAU.REPL.Groovy.ReorderSources true Set to false to disable the logic that determines the proper compilation order for your .groovy sources. Disabling this setting will break compilation unless your classes are trivial, so you should only disable it for debugging. CAU.Groovy.SourceDirs.1, CAU.Groovy.SourceDirs.2, ... Root directories for your Groovy sources. All .groovy files in all their subdirectories will be compiled into the JVM on startup. CAU.REPL.Groovy.Startup.Scripts.1 CAU.REPL.Groovy.Startup.Scripts.2, ... Each Groovy script file you list here will be executed in the REPL whenever you connect to it as if you had typed it there. CAU.REPL.Groovy.Startup.Commands.1 CAU.REPL.Groovy.Startup.Commands.2, ... Each Groovy command you list here will be executed in the REPL whenever you connect to it as if you had typed it there. CAU.REPL.EditorSSH /usr/bin/vim --not-a-term The editor to use for interactive file editing within the SSH environment. Must be able to run without a TTY. CAU.REPL.Enabled false If set, the REPL will listen for SSH connections. CAU.REPL.Log.Trace false Enable very fine grained logging of the REPL's internals. Only use this for debugging. CAU.REPL.MaxBreakpoints 20 Maximum number of breakpoints that can remain uncontinued at a given time. Further triggered breakpoints will be dropped. CAU.REPL.SSH.ListenAddr 127.0.0.1 The address that the REPL should listen on for SSH connections. Protect outside access to this port as you would protect a normal SSH port with shell access: users who connect can execute arbitrary commands. CAU.REPL.SSH.ListenPort 8512 The port that the REPL should listen on for SSH connections. CAU.REPL.SSH.TimeoutSeconds 43200 (12h) Disconnect SSH connections after they have been idle for this many seconds.","title":"MyCoRe Plugin Properties"},{"location":"extending/","text":"Extending your Target with Groovy Classes You can use the REPL's bundled Groovy environment to extend your target application with your own Groovy classes. Those classes might either be entirely new - ready to be integrated using the application's own dependency injection mechanism - or they might be new versions of the application's own classes, which you can tweak to your liking. When you override a pre-existing class, you can alter the application's behavior even if it does not provide a mechanism for dependency injection. Important If you distribute your own application-specific Groovy classes, you need to comply with your target application's license. Licenses such as the GPL have special provisions for aggregated works such as these. Always remember to check what is permitted according to your target's license conditions. Adding new classes to your application is generally very simple. The exact method depends on whether on you use the universal REPL Java agent, or the MyCoRe plugin. Adding new classes - Agent To add new classes to your application using the universal agent, it needs to be properly set up first. The relevant configuration properties that you need to set up concern the ClassPath ( CAU.Groovy.ClassPath and maybe CAU.JavaAgent.ClassPath ), the class loader (you need to enable either CAU.Groovy.UseSystemClassLoader or CAU.JavaAgent.Triggers ) and the locations of your .groovy sources ( CAU.Groovy.SourceDirs ). See the Installation section and the Configuration section for details. Once you have set these properties correctly, you can just place .groovy files in the source directories that you configured. The agent will automatically compile them and place them into the ClassLoader that you configured as soon as possible. Load order and timing are often critical to integrate you classes into an existing application, as is choosing the correct ClassLoader. For dependency injection to work, your class must be available before your target's mechanism resolves the configured classes and they need to be findable in the ClassLoader hierarchy. Adding classes to the system ClassLoader When you enable the CAU.Groovy.UseSystemClassLoader property, the agent will compile your classes before any other class of your target gets loaded. This provides you with a clean slate. On the other hand, this may have certain disadvantages if your own class uses classes of the target - these will also be loaded into the system ClassLoader, which can cause problems in the target if it expects its classes to be loaded in a special separate ClassLoader (web applications running in servlet containers are a typical example). You should have the agent trigger on the proper ClassLoader in those cases. Adding classes to an application ClassLoader To place your classes in a special ClassLoader, use the CAU.JavaAgent.Triggers property instead (see the Installation section ). In this case, your Groovy sources will be compiled right after the first trigger class of your target was loaded and placed in the same ClassLoader as that triggering class. Adding classes to the REPL only If you only intend to use your classes from the interactive REPL, you don't have to set either of these two properties and can just leave the REPL at its default settings. in this case, they will be loaded into a separate ClassLoader that only the REPL itself can see. Adding new classes - MyCoRe To add classes to your MyCoRe installation, add their source directories to your mycore.properties file as lines in the form of CAU.Groovy.SourceDirs.1=... , CAU.Groovy.SourceDirs.2=... , and so forth. They will be compiled and loaded into MyCoRe's own ClassLoader as soon as MyCoRe initializes the REPL plugin. This is typically early enough to use your new classes (e.g. as an event handler) by simply referencing it by name from the same mycore.properties file. This allows you to easily extend MyCoRe without creating your own plugins. If you need your own class available earlier in MyCoRe's lifecycle, you should employ the hybrid approach of using both the MyCoRe plugin and the agent at the same time. See the Installation section for details. Remember that in the hybrid case, only the sources you directly pass via the Java command-line are compiled early. The sources from mycore.properties will still be compiled later during the normal MyCoRe plugin initialization. Examples: // here is a MyCoRe event handler implemented in Groovy package foo import org.mycore.common.events.MCREventHandlerBase import org.mycore.datamodel.metadata.MCRObject import org.mycore.common.events.MCREvent import de.uni_kiel.rz.fdr.repl.REPLLog class GroovyTestEventHandler extends MCREventHandlerBase { @Override protected void handleObjectUpdated(MCREvent evt, MCRObject obj) { REPLLog.info(\"Groovy Event Handler saw: {}\", obj.getId()) } } /* 1. Save this file with a \".groovy\" extension to a new directory 2. echo \"CAU.Groovy.SourceDirs.1=/path/to/your/dir\" >> /path/to/mycore.properties 3. echo \"MCR.EventHandler.MCRObject.933.Class=foo.GroovyTestEventHandler\" >> /path/to/mycore.properties */ Patching existing classes You might want to override the behavior of your target's own classes or of libraries which your target uses ( \"patching\" a class). The easiest way to achieve this is to simply add a Groovy source file that contains a class with the same name in the same package as your target class and make sure that it is compiled before your target tries to load its version. Using this method, you need to re-implement all the methods of the class you are replacing yourself, even those whose behavior you did not mean to alter. To make this process more convenient, cau-repl has a special feature that simplifies the patching process and does not require access to the target's source code. To use cau-repl's patching feature, annotate your own version of the class with a special annotation: Patch a class Class Annotation @Patches You should add this annotation to your own Groovy class with which you intend to override an existing class of your target or its libraries. Do not specify a superclass: it will be set up automatically. The package and name of your class must be identical to package and name of the target class. When cau-repl encounters the @Patches annotation during compilation, it will first locate the target class in the class path, load it into the ClassLoader under a different name (the suffix _CAUREPL will be appended to the original name) and set this renamed class as the superclass of your Groovy class. The result of this transformation is that your Groovy class will replace the target class in the application, while the functionality of the target continues to be available to you from your Groovy class. You only have to override the methods that you would like to alter and can inherit the rest. One may invoke its methods via super() , including access to all its private methods and fields, which cau-repl will transparently patch to public access. You do not have to import this annotation manually. It is always available. Warning This is an experimental feature. Expect problems. Do not patch database-backed classes: the renaming and subclassing of them may cause damage to your database structure and state. Optional Named Parameters String classPath = <REPL's class path> - Specify an alternate class path in which the target class and its dependencies can be found. boolean force = false - cau-repl will try to prevent a database-backed class (i.e. JPA-enabled) from being patched. The goal is to prevent destructive changes to your database induced by renaming classes and methods during the patching process. Set this to true to override this check, but only if you know what you are doing at the risk of your database state. boolean makePublic = true - By default, non-public methods and fields as well as final methods and classes of the target will be set public and not-final during the patching process. Set this to false to preserve all original access modifiers, at the cost of making those methods not-overridable. boolean preserveSuper = true - By default, we will try to preserve access to the target's original superclass during the patching process. Disable this to prevent this logic, at the cost of losing this access. String stripAnnotations - A comma separated list of annotations to remove from your target class before it is loaded. You can either pass the annotation names fully qualified (i.e. including their package prefix) or in short form (just their name without any package). Hint: If your patch target class contains inner classes, these will be renamed along with the target. Depending on the types of interactions between outer and inner classes, that may or may not be appropriate for your situation. If this causes your trouble (e.g. method signature mismatches), consider adding an inner class with the same name as the target's to your own patching class, which inherits from the Target_CAUREPL.InnerClass class. Then you can fine-tune its behavior. Function patcheeSuper(method, ...parameters) This function provides access to the methods of the @Patches target's original superclass, which are lost after patching, because the target class is now the superclass. You do not have to import this function manually. It is always available. Positional Parameters String method - The name of the method you would like to invoke from the target's superclass. Object parameters optional, repeatable - The parameters of the function call. Returns the result that invoking super.method(parameters) from the target would have returned. Examples: // Let's patch the apache-commons-text TextStringBuilder class. // Install its .jar to your classpath. MyCoRe already includes it. // api: https://commons.apache.org/proper/commons-text/apidocs/org/apache/commons/text/TextStringBuilder.html // source: https://github.com/apache/commons-text/blob/master/src/main/java/org/apache/commons/text/TextStringBuilder.java package org.apache.commons.text @Patches class TextStringBuilder { @Override String toString() { def s = super.toString() return \"Bork\".equals(s) ? \"Bork Bork Bork\" : s } } /* groovy:000> x = new org.apache.commons.text.TextStringBuilder() ===> groovy:000> x.append(\"Bo\") ===> Bo groovy:000> x.append(\"rk\") ===> Bork Bork Bork */ Adding interactive breakpoints You can add interactive breakpoints to your Groovy classes. When they trigger, they transfer control to the SSH interface, where you can inspect their payload and then pass data back to the function which triggered them. The breakpoints are implemented as a normal function, so you can easily create conditional breakpoints by nesting them in an if statement. See the Managing breakpoints section to learn about the corresponding REPL functionality. Function replbreakpoint(name, extra, timeoutMillis) Pauses execution of the current thread and transfers the extra object to the REPL. When this breakpoint is continued from the REPL, it will return the feedback data passed interactively from there. You do not have to import this function manually. It is always available. Positional Parameters String name optional - A descriptive name of this breakpoint instance allowing for easy identification in the breakpoint list (including ids or timestamps is a good idea). If omitted, it will be auto-generated from the thread's stack. Object extra optional - Any related extra data you would like to make available in the REPL. Long timeoutMillis optional - Limit the amount of time that this breakpoint will wait for. When this much time has passed and no one has resumed the breakpoint instance from the REPL, it will continue anyway. The default behavior is to wait forever ( timeoutMillis = null ). Returns the feedback value passed from the REPL, or null if none was passed. Examples: // here is a conditional breakpoint that also returns a value package foo class Example { def doSomething(Integer data) { // trigger a breakpoint only if input > 100 if ((data?:0) > 100) { def feedback = replbreakpoint(\"foo.Example ${data}\", data) // if the breakpoint was continued from the REPL without feedback, continue (\":B 0\") // else (\":B 0 not good\") abort if (feedback) throw new RuntimeException(\"Abort at breakpoint requested: ${feedback}\") } return (data?:0) * 2 } } Related Classes: REPLBreakpoint provides additional functionality related to breakpoints. Updating methods at runtime Dynamic languages that run in the JVM (like Groovy or JRuby) allow you to change the implementation of your classes at runtime without reloading your entire application. This feature has until now always be confined to the dynamic parts of the JVM: Java code interacting with your Groovy objects will not pick up the changes to their definition and continue to use the original class bytecode. Only calls initiated from Groovy code itself can use the updated implementations. cau-repl includes a very experimental feature which works around this limitation, allowing you to update a method's implementation and have it take effect everywhere in the JVM - including from Java callsites. Class Annotation @Dynamize Classes that have this annotation are transparently augmented with a dynamic method dispatcher, enabling you to update a method's code and have the change be visible from the non-dynamic Java world in your JVM without restarting the application. You do not have to import this annotation manually. It is always available. Warning Consider this a proof-of-concept. Expect bugs and problems, also a substantial performance overhead for each method-call into the affected classes. Do not enable in a production environment. Optional Named Parameters boolean inherit = true - Subclasses of dynamized classes will automatically be dynamized as well. If you'd like to prevent this, set this to false (which is strongly discouraged and will cause all sorts of problems). You update a method by assigning a Closure to its metaclass, like using Groovy's ExpandoMetaClass . See below for an example. Because your updated code runs inside a closure, some of Groovy's language features are not readily available (especially super is missing). cau-repl includes some helper functions that you can use instead: Function dynamicSuper(method, ...parameters) dynamicSuper(int parents, method, ...parameters) These functions provide access to the methods of your class' superclass, which are not available from a closure. They are intended to be used from closure that you apply to a @Dynamize metaclass. You do not have to import these functions manually. It is always available. Positional Parameters int parents = 1 optional - You may select a (grand-)parent in the class hierarchy (1 = super , 2 = super.super , ...). String method - The name of the method you would like to invoke from your class' superclass. Object parameters optional, repeatable - The parameters of the function call. Returns the result that invoking super.method(parameters) from your class would have returned. Function dynamicPatcheeSuper(method, ...parameters) This function is intended to be used from closure that you apply to a @Patches @Dynamize metaclass. They provide access to the methods of your class' patch-target superclass, which is shadowed due to the patching process. You do not have to import these functions manually. It is always available. Positional Parameters String method - The name of the method you would like to invoke from your patch target's superclass. Object parameters optional, repeatable - The parameters of the function call. Returns the result that invoking super.method(parameters) from your target would have returned. Examples: package foo @Dynamize class Example { int data static String greetMe(def name) { return \"Hi, ${name}\" } Example(int data) { this.data = data } int calculate() { return data * 2 } } /* groovy:000> compile(\"example.groovy\") ===> de.uni_kiel.rz.fdr.repl.groovy.GroovySourceDirectory@d6b75cb groovy:000> import \"foo.Example\" ===> de.uni_kiel.rz.fdr.repl.REPL, de.uni_kiel.rz.fdr.repl.REPLLog, de.uni_kiel.rz.fdr.repl.REPLLogEntry, de.uni_kiel.rz.fdr.repl.REPLLog.LOG_TARGETS, de.uni_kiel.rz.fdr.repl.REPLBreakpoint, de.uni_kiel.rz.fdr.repl.REPLJob, de.uni_kiel.rz.fdr.repl.REPLJobCallbackAutoTune, foo.Example groovy:000> Example.greetMe(\"Bob\") ===> Hi, Bob groovy:000> e = new Example(3) ===> foo.Example@5dd95ba8 groovy:000> e.calculate() ===> 6 // redefining a static method groovy:000> Example.metaClass.static.greetMe = { name -> \"Hello, ${name}\" } ===> groovysh_evaluate$_run_closure1@c60b893 groovy:000> Example.greetMe(\"Bob\") ===> Hello, Bob // redefining an instance method groovy:000> e.metaClass.calculate = { return data * 10 } ===> groovysh_evaluate$_run_closure1@3cfb3247 groovy:000> e.calculate() ===> 30 */","title":"Extending your Target"},{"location":"extending/#extending-your-target-with-groovy-classes","text":"You can use the REPL's bundled Groovy environment to extend your target application with your own Groovy classes. Those classes might either be entirely new - ready to be integrated using the application's own dependency injection mechanism - or they might be new versions of the application's own classes, which you can tweak to your liking. When you override a pre-existing class, you can alter the application's behavior even if it does not provide a mechanism for dependency injection. Important If you distribute your own application-specific Groovy classes, you need to comply with your target application's license. Licenses such as the GPL have special provisions for aggregated works such as these. Always remember to check what is permitted according to your target's license conditions. Adding new classes to your application is generally very simple. The exact method depends on whether on you use the universal REPL Java agent, or the MyCoRe plugin.","title":"Extending your Target with Groovy Classes"},{"location":"extending/#adding-new-classes-agent","text":"To add new classes to your application using the universal agent, it needs to be properly set up first. The relevant configuration properties that you need to set up concern the ClassPath ( CAU.Groovy.ClassPath and maybe CAU.JavaAgent.ClassPath ), the class loader (you need to enable either CAU.Groovy.UseSystemClassLoader or CAU.JavaAgent.Triggers ) and the locations of your .groovy sources ( CAU.Groovy.SourceDirs ). See the Installation section and the Configuration section for details. Once you have set these properties correctly, you can just place .groovy files in the source directories that you configured. The agent will automatically compile them and place them into the ClassLoader that you configured as soon as possible. Load order and timing are often critical to integrate you classes into an existing application, as is choosing the correct ClassLoader. For dependency injection to work, your class must be available before your target's mechanism resolves the configured classes and they need to be findable in the ClassLoader hierarchy. Adding classes to the system ClassLoader When you enable the CAU.Groovy.UseSystemClassLoader property, the agent will compile your classes before any other class of your target gets loaded. This provides you with a clean slate. On the other hand, this may have certain disadvantages if your own class uses classes of the target - these will also be loaded into the system ClassLoader, which can cause problems in the target if it expects its classes to be loaded in a special separate ClassLoader (web applications running in servlet containers are a typical example). You should have the agent trigger on the proper ClassLoader in those cases. Adding classes to an application ClassLoader To place your classes in a special ClassLoader, use the CAU.JavaAgent.Triggers property instead (see the Installation section ). In this case, your Groovy sources will be compiled right after the first trigger class of your target was loaded and placed in the same ClassLoader as that triggering class. Adding classes to the REPL only If you only intend to use your classes from the interactive REPL, you don't have to set either of these two properties and can just leave the REPL at its default settings. in this case, they will be loaded into a separate ClassLoader that only the REPL itself can see.","title":"Adding new classes - Agent"},{"location":"extending/#adding-new-classes-mycore","text":"To add classes to your MyCoRe installation, add their source directories to your mycore.properties file as lines in the form of CAU.Groovy.SourceDirs.1=... , CAU.Groovy.SourceDirs.2=... , and so forth. They will be compiled and loaded into MyCoRe's own ClassLoader as soon as MyCoRe initializes the REPL plugin. This is typically early enough to use your new classes (e.g. as an event handler) by simply referencing it by name from the same mycore.properties file. This allows you to easily extend MyCoRe without creating your own plugins. If you need your own class available earlier in MyCoRe's lifecycle, you should employ the hybrid approach of using both the MyCoRe plugin and the agent at the same time. See the Installation section for details. Remember that in the hybrid case, only the sources you directly pass via the Java command-line are compiled early. The sources from mycore.properties will still be compiled later during the normal MyCoRe plugin initialization. Examples: // here is a MyCoRe event handler implemented in Groovy package foo import org.mycore.common.events.MCREventHandlerBase import org.mycore.datamodel.metadata.MCRObject import org.mycore.common.events.MCREvent import de.uni_kiel.rz.fdr.repl.REPLLog class GroovyTestEventHandler extends MCREventHandlerBase { @Override protected void handleObjectUpdated(MCREvent evt, MCRObject obj) { REPLLog.info(\"Groovy Event Handler saw: {}\", obj.getId()) } } /* 1. Save this file with a \".groovy\" extension to a new directory 2. echo \"CAU.Groovy.SourceDirs.1=/path/to/your/dir\" >> /path/to/mycore.properties 3. echo \"MCR.EventHandler.MCRObject.933.Class=foo.GroovyTestEventHandler\" >> /path/to/mycore.properties */","title":"Adding new classes - MyCoRe"},{"location":"extending/#patching-existing-classes","text":"You might want to override the behavior of your target's own classes or of libraries which your target uses ( \"patching\" a class). The easiest way to achieve this is to simply add a Groovy source file that contains a class with the same name in the same package as your target class and make sure that it is compiled before your target tries to load its version. Using this method, you need to re-implement all the methods of the class you are replacing yourself, even those whose behavior you did not mean to alter. To make this process more convenient, cau-repl has a special feature that simplifies the patching process and does not require access to the target's source code. To use cau-repl's patching feature, annotate your own version of the class with a special annotation: Patch a class Class Annotation @Patches You should add this annotation to your own Groovy class with which you intend to override an existing class of your target or its libraries. Do not specify a superclass: it will be set up automatically. The package and name of your class must be identical to package and name of the target class. When cau-repl encounters the @Patches annotation during compilation, it will first locate the target class in the class path, load it into the ClassLoader under a different name (the suffix _CAUREPL will be appended to the original name) and set this renamed class as the superclass of your Groovy class. The result of this transformation is that your Groovy class will replace the target class in the application, while the functionality of the target continues to be available to you from your Groovy class. You only have to override the methods that you would like to alter and can inherit the rest. One may invoke its methods via super() , including access to all its private methods and fields, which cau-repl will transparently patch to public access. You do not have to import this annotation manually. It is always available. Warning This is an experimental feature. Expect problems. Do not patch database-backed classes: the renaming and subclassing of them may cause damage to your database structure and state. Optional Named Parameters String classPath = <REPL's class path> - Specify an alternate class path in which the target class and its dependencies can be found. boolean force = false - cau-repl will try to prevent a database-backed class (i.e. JPA-enabled) from being patched. The goal is to prevent destructive changes to your database induced by renaming classes and methods during the patching process. Set this to true to override this check, but only if you know what you are doing at the risk of your database state. boolean makePublic = true - By default, non-public methods and fields as well as final methods and classes of the target will be set public and not-final during the patching process. Set this to false to preserve all original access modifiers, at the cost of making those methods not-overridable. boolean preserveSuper = true - By default, we will try to preserve access to the target's original superclass during the patching process. Disable this to prevent this logic, at the cost of losing this access. String stripAnnotations - A comma separated list of annotations to remove from your target class before it is loaded. You can either pass the annotation names fully qualified (i.e. including their package prefix) or in short form (just their name without any package). Hint: If your patch target class contains inner classes, these will be renamed along with the target. Depending on the types of interactions between outer and inner classes, that may or may not be appropriate for your situation. If this causes your trouble (e.g. method signature mismatches), consider adding an inner class with the same name as the target's to your own patching class, which inherits from the Target_CAUREPL.InnerClass class. Then you can fine-tune its behavior. Function patcheeSuper(method, ...parameters) This function provides access to the methods of the @Patches target's original superclass, which are lost after patching, because the target class is now the superclass. You do not have to import this function manually. It is always available. Positional Parameters String method - The name of the method you would like to invoke from the target's superclass. Object parameters optional, repeatable - The parameters of the function call. Returns the result that invoking super.method(parameters) from the target would have returned. Examples: // Let's patch the apache-commons-text TextStringBuilder class. // Install its .jar to your classpath. MyCoRe already includes it. // api: https://commons.apache.org/proper/commons-text/apidocs/org/apache/commons/text/TextStringBuilder.html // source: https://github.com/apache/commons-text/blob/master/src/main/java/org/apache/commons/text/TextStringBuilder.java package org.apache.commons.text @Patches class TextStringBuilder { @Override String toString() { def s = super.toString() return \"Bork\".equals(s) ? \"Bork Bork Bork\" : s } } /* groovy:000> x = new org.apache.commons.text.TextStringBuilder() ===> groovy:000> x.append(\"Bo\") ===> Bo groovy:000> x.append(\"rk\") ===> Bork Bork Bork */","title":"Patching existing classes"},{"location":"extending/#adding-interactive-breakpoints","text":"You can add interactive breakpoints to your Groovy classes. When they trigger, they transfer control to the SSH interface, where you can inspect their payload and then pass data back to the function which triggered them. The breakpoints are implemented as a normal function, so you can easily create conditional breakpoints by nesting them in an if statement. See the Managing breakpoints section to learn about the corresponding REPL functionality. Function replbreakpoint(name, extra, timeoutMillis) Pauses execution of the current thread and transfers the extra object to the REPL. When this breakpoint is continued from the REPL, it will return the feedback data passed interactively from there. You do not have to import this function manually. It is always available. Positional Parameters String name optional - A descriptive name of this breakpoint instance allowing for easy identification in the breakpoint list (including ids or timestamps is a good idea). If omitted, it will be auto-generated from the thread's stack. Object extra optional - Any related extra data you would like to make available in the REPL. Long timeoutMillis optional - Limit the amount of time that this breakpoint will wait for. When this much time has passed and no one has resumed the breakpoint instance from the REPL, it will continue anyway. The default behavior is to wait forever ( timeoutMillis = null ). Returns the feedback value passed from the REPL, or null if none was passed. Examples: // here is a conditional breakpoint that also returns a value package foo class Example { def doSomething(Integer data) { // trigger a breakpoint only if input > 100 if ((data?:0) > 100) { def feedback = replbreakpoint(\"foo.Example ${data}\", data) // if the breakpoint was continued from the REPL without feedback, continue (\":B 0\") // else (\":B 0 not good\") abort if (feedback) throw new RuntimeException(\"Abort at breakpoint requested: ${feedback}\") } return (data?:0) * 2 } } Related Classes: REPLBreakpoint provides additional functionality related to breakpoints.","title":"Adding interactive breakpoints"},{"location":"extending/#updating-methods-at-runtime","text":"Dynamic languages that run in the JVM (like Groovy or JRuby) allow you to change the implementation of your classes at runtime without reloading your entire application. This feature has until now always be confined to the dynamic parts of the JVM: Java code interacting with your Groovy objects will not pick up the changes to their definition and continue to use the original class bytecode. Only calls initiated from Groovy code itself can use the updated implementations. cau-repl includes a very experimental feature which works around this limitation, allowing you to update a method's implementation and have it take effect everywhere in the JVM - including from Java callsites. Class Annotation @Dynamize Classes that have this annotation are transparently augmented with a dynamic method dispatcher, enabling you to update a method's code and have the change be visible from the non-dynamic Java world in your JVM without restarting the application. You do not have to import this annotation manually. It is always available. Warning Consider this a proof-of-concept. Expect bugs and problems, also a substantial performance overhead for each method-call into the affected classes. Do not enable in a production environment. Optional Named Parameters boolean inherit = true - Subclasses of dynamized classes will automatically be dynamized as well. If you'd like to prevent this, set this to false (which is strongly discouraged and will cause all sorts of problems). You update a method by assigning a Closure to its metaclass, like using Groovy's ExpandoMetaClass . See below for an example. Because your updated code runs inside a closure, some of Groovy's language features are not readily available (especially super is missing). cau-repl includes some helper functions that you can use instead: Function dynamicSuper(method, ...parameters) dynamicSuper(int parents, method, ...parameters) These functions provide access to the methods of your class' superclass, which are not available from a closure. They are intended to be used from closure that you apply to a @Dynamize metaclass. You do not have to import these functions manually. It is always available. Positional Parameters int parents = 1 optional - You may select a (grand-)parent in the class hierarchy (1 = super , 2 = super.super , ...). String method - The name of the method you would like to invoke from your class' superclass. Object parameters optional, repeatable - The parameters of the function call. Returns the result that invoking super.method(parameters) from your class would have returned. Function dynamicPatcheeSuper(method, ...parameters) This function is intended to be used from closure that you apply to a @Patches @Dynamize metaclass. They provide access to the methods of your class' patch-target superclass, which is shadowed due to the patching process. You do not have to import these functions manually. It is always available. Positional Parameters String method - The name of the method you would like to invoke from your patch target's superclass. Object parameters optional, repeatable - The parameters of the function call. Returns the result that invoking super.method(parameters) from your target would have returned. Examples: package foo @Dynamize class Example { int data static String greetMe(def name) { return \"Hi, ${name}\" } Example(int data) { this.data = data } int calculate() { return data * 2 } } /* groovy:000> compile(\"example.groovy\") ===> de.uni_kiel.rz.fdr.repl.groovy.GroovySourceDirectory@d6b75cb groovy:000> import \"foo.Example\" ===> de.uni_kiel.rz.fdr.repl.REPL, de.uni_kiel.rz.fdr.repl.REPLLog, de.uni_kiel.rz.fdr.repl.REPLLogEntry, de.uni_kiel.rz.fdr.repl.REPLLog.LOG_TARGETS, de.uni_kiel.rz.fdr.repl.REPLBreakpoint, de.uni_kiel.rz.fdr.repl.REPLJob, de.uni_kiel.rz.fdr.repl.REPLJobCallbackAutoTune, foo.Example groovy:000> Example.greetMe(\"Bob\") ===> Hi, Bob groovy:000> e = new Example(3) ===> foo.Example@5dd95ba8 groovy:000> e.calculate() ===> 6 // redefining a static method groovy:000> Example.metaClass.static.greetMe = { name -> \"Hello, ${name}\" } ===> groovysh_evaluate$_run_closure1@c60b893 groovy:000> Example.greetMe(\"Bob\") ===> Hello, Bob // redefining an instance method groovy:000> e.metaClass.calculate = { return data * 10 } ===> groovysh_evaluate$_run_closure1@3cfb3247 groovy:000> e.calculate() ===> 30 */","title":"Updating methods at runtime"},{"location":"installation/","text":"Installation cau-repl can be built in one of two flavors the standard build is an MIT-licensed universal Java agent that can be used with any Java application the GPL build is also a MyCoRe plugin, in addition to the Java agent functionality of the standard build Universal Java Agent Compiling Compile cau-repl as a universal Java agent with Maven: mvn clean package # alternatively, if you would also like to run the integration test: # mvn clean install This will produce the following two JARs: target/cau-repl-X.Y.Z-fatjar-mit.jar can be used as a standalone Java agent and contains all of cau-repls dependencies target/cau-repl-agent-X.Y.Z.jar is an optional lightweight loader-only agent that can be used to load the full fatjar into a specific classloader. Use this if your application places its classes in a non-default classloader (e.g. web applications in a servlet container). See the Classloader Selection section for details. Loading the Agent To simply get access to the SSH REPL, load cau-repl as a Java agent. You need to pass a special parameter to your Java command: java -javaagent:/path/to/cau-repl-X.Y.Z-fatjar-mit.jar ... This also allows you to compile your own classes and use them in the REPL. If you would like to extend your own classes' availability to the entire application (and not just the REPL), they need to be loaded into the system-default classloader. Then you should configure cau-repl like this: java -javaagent:/path/to/cau-repl-X.Y.Z-fatjar-mit.jar -DCAU.Groovy.UseSystemClassLoader=true ... If you use the system-default classloader and loading your classes fails with an exception, you might also need to disable the access protection provided by Java's module system (potentially impacting your target's security if it depends on it). Whether this step is necessary, depends on your target application: java -javaagent:/path/to/cau-repl-X.Y.Z-fatjar-mit.jar --add-opens 'java.base/java.lang=ALL-UNNAMED' -DCAU.Groovy.UseSystemClassLoader=true ... The REPL will listen for SSH connections on port 8512 on the local interface. You can use any username to log in. A per-session password will be printed to STDERR on startup. Be careful to make sure that it does not end up in a public logfile , e.g. Systemd's journal. Any local user who can read this password can connect to the REPL and execute code with the permissions of your application. To secure your installation permanently, see the Configuration section for ways to set your own static password without producing log output. The configuration section also describes various parameters that you can use to customize ports, directories, etc. By default, cau-repl will store its state in the cau-repl directory, which it will create in the current working directory. If you do not see your application's classes in the REPL, you need to load cau-repl into a specific classloader. Classloader Selection To load cau-repl in a specific classloader of your application, place cau-repl-X.Y.Z-fatjar-noglp.jar in your application's classpath and use the lightweight loader JAR cau-repl-agent-X.Y.Z.jar as the agent. You can then configure the loader agent to place the main JAR into the same classloader that your application uses. Just identify a package or class that your target application will load and pass its resource path as a parameter to the loader agent: # use the classloader that loads the first class from the org.example.* package java -javagent:/path/to/cau-repl-agent-X.Y.Z.jar -DCAU.JavaAgent.Triggers=org/example/ # use the classloader that loads the class org.example.SomeClass java -javagent:/path/to/cau-repl-agent-X.Y.Z.jar -DCAU.JavaAgent.Triggers=org/example/SomeClass As before, you might also have to set the --add-opens 'java.base/java.lang=ALL-UNNAMED' parameter if you plan on changing or adding classes in your target. Note that this will have security implications for your target application if it depends on the separation provided by Java's module system. Remark : it is currently not possible to patch the class that the agent triggers on (by the time it is seen, it is too late to block it). So make sure to select a trigger that triggers in the correct classloader, but before the first class you would like to patch. MyCoRe plugin Compiling Compile cau-repl as a MyCoRe plugin with Maven: mvn -P gpl clean package # alternatively, if you would also like to run the integration test: # mvn -P gpl clean install This will produce the following two JARs: target/cau-repl-X.Y.Z-fatjar-gpl.jar can be used as a MyCoRe plugin (and also as a Java agent) target/cau-repl-agent-X.Y.Z.jar is an optional lightweight loader-only agent that can be used to load the full fatjar into a specific classloader. In a MyCoRe context, you would only have to use this if you want to give cau-repl priority over MyCoRe's basic classes in the JVM's class load order. This is only necessary if you want to use cau-repl to patch basic framework classes, so most MyCoRe users do not have to install this JAR. Loading the Plugin To load the cau-repl MyCoRe plugin, place the main JAR in your MyCoRe lib/ directory and enable it in your .properties file: cp /path/to/cau-repl-X.Y.Z-fatjar-gpl.jar /path/to/mycore/lib echo \"CAU.REPL.Enabled=true\" >> /path/to/mycore/mycore.properties Then (re-) start your servlet container. The REPL will listen for SSH connections on port 8512 on the localhost. You can log in with the username administrator and the corresponding MyCoRe password of the account. See the Configuration section for more settings that you can customize from your .properties . By default, cau-repl will store its state in the cau-repl subdirectory, which it will create in your MyCoRe installation's root. Loading the Plugin Earlier with the Agent When you patch libraries or define classes, load order is important. The MyCoRe plugin generally tries to load your Groovy classes as early as possible, but when you interact with lower layers of the stack, it is sometimes too late to do anything about that from the plugin. Most users will never have these issues and can skip this step, but if you try to patch a very basic class and fail because it was already loaded, you can add the agent as described here. Please note: these steps are to be performed in addition to the plugin installation steps above. Do not delete ot disable the main JAR. First copy the loader agent into place: cp path/to/cau-repl-agent-X.Y.Z.jar /path/to/mycore/lib Then add it to your servlet container's java arguments. E.g. for Tomcat, you would add something like this to your bin/setenv.sh file: # adjust paths as needed export JAVA_OPTS=\"$JAVA_OPTS -javaagent:/path/to/mycore/lib/cau-repl-agent-X.Y.Z.jar -DCAU.JavaAgent.ClassPath=/path/to/mycore/lib/* -DCAU.JavaAgent.SupportMode=true -DCAU.JavaAgent.Triggers=org/mycore/ -DCAU.Groovy.ClassPath=$CATALINA_HOME/lib/*:$CATALINA_HOME/webapps/ROOT/WEB-INF/lib/* -DCAU.Groovy.SourceDirs=/path/to/your/groovy-sources\" From now on, your Groovy sources in the /path/to/your/groovy-sources directory will be compiled before other MyCoRe classes, so they can patch any library that MyCoRe uses and are available from the very beginning of the application's lifecycle. You can continue to use the plugin as usual when you add the agent like this.","title":"Installation"},{"location":"installation/#installation","text":"cau-repl can be built in one of two flavors the standard build is an MIT-licensed universal Java agent that can be used with any Java application the GPL build is also a MyCoRe plugin, in addition to the Java agent functionality of the standard build","title":"Installation"},{"location":"installation/#universal-java-agent","text":"","title":"Universal Java Agent"},{"location":"installation/#compiling","text":"Compile cau-repl as a universal Java agent with Maven: mvn clean package # alternatively, if you would also like to run the integration test: # mvn clean install This will produce the following two JARs: target/cau-repl-X.Y.Z-fatjar-mit.jar can be used as a standalone Java agent and contains all of cau-repls dependencies target/cau-repl-agent-X.Y.Z.jar is an optional lightweight loader-only agent that can be used to load the full fatjar into a specific classloader. Use this if your application places its classes in a non-default classloader (e.g. web applications in a servlet container). See the Classloader Selection section for details.","title":"Compiling"},{"location":"installation/#loading-the-agent","text":"To simply get access to the SSH REPL, load cau-repl as a Java agent. You need to pass a special parameter to your Java command: java -javaagent:/path/to/cau-repl-X.Y.Z-fatjar-mit.jar ... This also allows you to compile your own classes and use them in the REPL. If you would like to extend your own classes' availability to the entire application (and not just the REPL), they need to be loaded into the system-default classloader. Then you should configure cau-repl like this: java -javaagent:/path/to/cau-repl-X.Y.Z-fatjar-mit.jar -DCAU.Groovy.UseSystemClassLoader=true ... If you use the system-default classloader and loading your classes fails with an exception, you might also need to disable the access protection provided by Java's module system (potentially impacting your target's security if it depends on it). Whether this step is necessary, depends on your target application: java -javaagent:/path/to/cau-repl-X.Y.Z-fatjar-mit.jar --add-opens 'java.base/java.lang=ALL-UNNAMED' -DCAU.Groovy.UseSystemClassLoader=true ... The REPL will listen for SSH connections on port 8512 on the local interface. You can use any username to log in. A per-session password will be printed to STDERR on startup. Be careful to make sure that it does not end up in a public logfile , e.g. Systemd's journal. Any local user who can read this password can connect to the REPL and execute code with the permissions of your application. To secure your installation permanently, see the Configuration section for ways to set your own static password without producing log output. The configuration section also describes various parameters that you can use to customize ports, directories, etc. By default, cau-repl will store its state in the cau-repl directory, which it will create in the current working directory. If you do not see your application's classes in the REPL, you need to load cau-repl into a specific classloader.","title":"Loading the Agent"},{"location":"installation/#classloader-selection","text":"To load cau-repl in a specific classloader of your application, place cau-repl-X.Y.Z-fatjar-noglp.jar in your application's classpath and use the lightweight loader JAR cau-repl-agent-X.Y.Z.jar as the agent. You can then configure the loader agent to place the main JAR into the same classloader that your application uses. Just identify a package or class that your target application will load and pass its resource path as a parameter to the loader agent: # use the classloader that loads the first class from the org.example.* package java -javagent:/path/to/cau-repl-agent-X.Y.Z.jar -DCAU.JavaAgent.Triggers=org/example/ # use the classloader that loads the class org.example.SomeClass java -javagent:/path/to/cau-repl-agent-X.Y.Z.jar -DCAU.JavaAgent.Triggers=org/example/SomeClass As before, you might also have to set the --add-opens 'java.base/java.lang=ALL-UNNAMED' parameter if you plan on changing or adding classes in your target. Note that this will have security implications for your target application if it depends on the separation provided by Java's module system. Remark : it is currently not possible to patch the class that the agent triggers on (by the time it is seen, it is too late to block it). So make sure to select a trigger that triggers in the correct classloader, but before the first class you would like to patch.","title":"Classloader Selection"},{"location":"installation/#mycore-plugin","text":"","title":"MyCoRe plugin"},{"location":"installation/#compiling_1","text":"Compile cau-repl as a MyCoRe plugin with Maven: mvn -P gpl clean package # alternatively, if you would also like to run the integration test: # mvn -P gpl clean install This will produce the following two JARs: target/cau-repl-X.Y.Z-fatjar-gpl.jar can be used as a MyCoRe plugin (and also as a Java agent) target/cau-repl-agent-X.Y.Z.jar is an optional lightweight loader-only agent that can be used to load the full fatjar into a specific classloader. In a MyCoRe context, you would only have to use this if you want to give cau-repl priority over MyCoRe's basic classes in the JVM's class load order. This is only necessary if you want to use cau-repl to patch basic framework classes, so most MyCoRe users do not have to install this JAR.","title":"Compiling"},{"location":"installation/#loading-the-plugin","text":"To load the cau-repl MyCoRe plugin, place the main JAR in your MyCoRe lib/ directory and enable it in your .properties file: cp /path/to/cau-repl-X.Y.Z-fatjar-gpl.jar /path/to/mycore/lib echo \"CAU.REPL.Enabled=true\" >> /path/to/mycore/mycore.properties Then (re-) start your servlet container. The REPL will listen for SSH connections on port 8512 on the localhost. You can log in with the username administrator and the corresponding MyCoRe password of the account. See the Configuration section for more settings that you can customize from your .properties . By default, cau-repl will store its state in the cau-repl subdirectory, which it will create in your MyCoRe installation's root.","title":"Loading the Plugin"},{"location":"installation/#loading-the-plugin-earlier-with-the-agent","text":"When you patch libraries or define classes, load order is important. The MyCoRe plugin generally tries to load your Groovy classes as early as possible, but when you interact with lower layers of the stack, it is sometimes too late to do anything about that from the plugin. Most users will never have these issues and can skip this step, but if you try to patch a very basic class and fail because it was already loaded, you can add the agent as described here. Please note: these steps are to be performed in addition to the plugin installation steps above. Do not delete ot disable the main JAR. First copy the loader agent into place: cp path/to/cau-repl-agent-X.Y.Z.jar /path/to/mycore/lib Then add it to your servlet container's java arguments. E.g. for Tomcat, you would add something like this to your bin/setenv.sh file: # adjust paths as needed export JAVA_OPTS=\"$JAVA_OPTS -javaagent:/path/to/mycore/lib/cau-repl-agent-X.Y.Z.jar -DCAU.JavaAgent.ClassPath=/path/to/mycore/lib/* -DCAU.JavaAgent.SupportMode=true -DCAU.JavaAgent.Triggers=org/mycore/ -DCAU.Groovy.ClassPath=$CATALINA_HOME/lib/*:$CATALINA_HOME/webapps/ROOT/WEB-INF/lib/* -DCAU.Groovy.SourceDirs=/path/to/your/groovy-sources\" From now on, your Groovy sources in the /path/to/your/groovy-sources directory will be compiled before other MyCoRe classes, so they can patch any library that MyCoRe uses and are available from the very beginning of the application's lifecycle. You can continue to use the plugin as usual when you add the agent like this.","title":"Loading the Plugin Earlier with the Agent"},{"location":"mycore/","text":"MyCoRe Integration If you compile cau-repl with GPL code enabled (the -gpl version), the REPL supports some additional command that provide better integration with MyCoRe than the default generic version. As a MyCoRe user, you should install the REPL as a MyCoRe plugin . In this section you will find outlined some additional features that you can use. Retrieving Documents There are numerous functions available for retrieving Documents from you repository. If you intend on working with a document's XML structure, please refer to the Working with XML section, which describes the functions related to those kinds of tasks. Get document IDs Function mcrids(...selector) This function returns the IDs of all documents (not including derivates) that match the given selector . Positional Parameters String | Collection<String> selector optional, repeatable - The selectors to search for. Each selector parameter instance can either be a String or a Collection of multiple selectors. Valid selectors are MyCoRe type strings (\" mods \"), base strings (\" foo_mods \") and strings representing MyCoRe IDs (\" foo_mods_00000001 \"). If you omit this parameter, all documents' IDs (excluding derivates) will be returned. Returns a list of the MCRObjectID IDs from your repository's documents matching any of your selectors. Get derivate IDs Function mcrderids(...selector) This function returns the IDs of all derivates that match the given selector . Positional Parameters String | Collection<String> selector optional, repeatable - The selectors to search for. Each selector parameter instance can either be a String or a Collection of multiple selectors. Valid selectors are MyCoRe type strings (\" derivate \"), base strings (\" foo_derivate \") and strings representing MyCoRe IDs (\" foo_derivate_00000001 \"). If you omit this parameter, all derivates' IDs will be returned. Returns a list of the MCRObjectID IDs from your repository's derivates matching any of your selectors. Retrieving documents Function mcrobj(selector, filter) This function returns all documents matching both selector and filter arguments. Positional Parameters String | Collection<String> selector optional - The selectors to search for. See the mcrids() function for details. String | Closure filter optional - An additional filter to apply after the selector. It can either be an XPath string (returning only those documents for which its result is not empty), or a Closure (returning only those documents for which its results is truthy). If you omit this parameter, exactly the documents matching the selector will be returned. Returns the list of MCRObjects matching your criteria. In the special case where your selector is an MCRObjectID or a valid MyCoRe ID in string form, the single result is automatically unwrapped and returned as an MCRObject without a list (or null if not matched). Retrieving MODS documents Function mcrmods(selector, filter) This function returns all MODS documents matching both selector and filter arguments. Positional Parameters String | Collection<String> selector = \"mods\" optional - The selectors to search for. See the mcrids() function for details. String | Closure filter optional - An additional filter to apply after the selector. See the mcrobj() function for details. Returns the list of MCRMODSWrapper objects matching your criteria. In the special case where your selector is an MCRObjectID or a valid MyCoRe ID in string form, the single result is automatically unwrapped and returned as an MCRMODSWrapper without a list (or null if not matched). Retrieving derivates Function mcrder(selector, filter) This function returns all derivates matching both selector and filter arguments. Positional Parameters String | Collection<String> selector optional - The selectors to search for. See the mcrderids() function for details. String | Closure filter optional - An additional filter to apply after the selector. See the mcrobj() function for details. Returns the list of MCRDerivate objects matching your criteria. In the special case where your selector is an MCRObjectID or a valid MyCoRe ID in string form, the single result is automatically unwrapped and returned as an MCRDerivate without a list (or null if not matched). Streaming documents Function mcrstream(selector, filter) Streams all documents matching both selector and filter arguments. Documents are loaded lazily, so you can abort the stream early without having to scan the entire repository. Positional Parameters String | Collection<String> selector optional - The selectors to search for. See the mcrids() function for details. String | Closure filter optional - An additional filter to apply after the selector. See the mcrobj() function for details. Returns a Stream of MCRObject instances matching your arguments in repository default order. Streaming MODS documents Function mcrmodsstream(filter, selector) Streams all MODS documents matching both selector and filter arguments. Documents are loaded lazily, so you can abort the stream early without having to scan the entire repository. Positional Parameters String | Collection<String> selector = \"mods\" optional - The selectors to search for. See the mcrids() function for details. String | Closure filter optional - An additional filter to apply after the selector. See the mcrobj() function for details. Returns a Stream of MCRMODSWrapper instances matching your arguments in repository default order. Streaming derivates Function mcrderstream(filter, selector) Streams all derivates matching both selector and filter arguments. Derivates are loaded lazily, so you can abort the stream early without having to scan the entire repository. Positional Parameters String | Collection<String> selector optional - The selectors to search for. See the mcrderids() function for details. String | Closure filter optional - An additional filter to apply after the selector. See the mcrobj() function for details. Returns a Stream of MCRDerivate instances matching your arguments in repository default order. Retrieving derivates' files Function mcrderfiles(...selector) Retrieve all files of the derivate(s) matching the selector . Positional Parameters String | Collection<String> selector optional, repeatable - The selectors to search for. See the mcrderids() function for details. Returns in a single list: for each file a Map containing the keys derid (as MCRObjectID ), path (as MCRPath ) and attributes (as MCRFileAttributes ). The same functionality is also mirrored for Derivate instances: File Mixins for org.mycore.datamodel.metadata.MCRDerivate derivate.files invoked on an MCRDerivate instance also returns the derivate's files in the same format as mcrderfiles() . Examples: // generating a list of all \"foo_mods\" documents groovy:000> mcrobj(\"foo_mods\") ===> [foo_mods_00000001, foo_mods_00000002, foo_mods_00000003, [...] // finding the first document with a maindoc named 'sample.pdf' groovy:000> mcrstream(null, \"/mycoreobject/structure/derobjects/derobject[maindoc='sample.pdf']\").findFirst() ===> Optional[foo_mods_00000101] // generating a list of all MODS documents that were created by the admin user groovy:000> mcrmods(\"mods\", {it.getServiceFlag(\"createdby\").equals(\"administrator\")}) ===> [MCRMODSWrapper(foo_mods_00000004), MCRMODSWrapper(foo_mods_00000005), MCRMODSWrapper(foo_mods_00000009), [...] // find all derivates' files whose on-disk md5 checksum does not match the on-record checksum groovy:000> mcrderfiles().findAll{ !it.path.toPhysicalPath().toFile().bytes.md5().equals(it.attributes.md5sum) } ===> [] Working with XML There are specialized functions available for retrieving documents if you plan to work with their XML structure directly. In contrast to the functions that were introduced in the last section, these XML-centric functions allow you to change the XML directly on the element-level and write your changes back to the repository after you are done. Retrieving documents' XML Function mcrxml(selector, filter) Retrieves the XML data of the documents matching selector and filter . Positional Parameters String | Collection<String> selector optional - The selectors to search for. See the mcrids() function for details. String | Closure filter optional - An additional filter to apply after the selector. See the mcrobj() function for details. Returns the list of JDOM Document objects matching your criteria. In the special case where your selector is an MCRObjectID or a valid MyCoRe ID in string form, the single result is automatically unwrapped and returned as a JDOM document without a list (or null if not matched). Retrieving derivates' XML Function mcrderxml(selector, filter) Retrieves the XML data of the derivates matching selector and filter . Positional Parameters String | Collection<String> selector optional - The selectors to search for. See the mcrderids() function for details. String | Closure filter optional - An additional filter to apply after the selector. See the mcrobj() function for details. Returns the list of JDOM Document objects matching your criteria. In the special case where your selector is an MCRObjectID or a valid MyCoRe ID in string form, the single result is automatically unwrapped and returned as a JDOM document without a list (or null if not matched). Streaming documents' XML Function mcrstreamxml(selector, filter) Streams the XML representation of all documents matching both selector and filter arguments. Documents are loaded lazily, so you can abort the stream early without having to scan the entire repository. Positional Parameters String | Collection<String> selector optional - The selectors to search for. See the mcrids() function for details. String | Closure filter optional - An additional filter to apply after the selector. See the mcrobj() function for details. Returns a Stream of JDOM Document instances matching your arguments in repository default order. Streaming derivates' XML Function mcrderstreamxml(selector, filter) Streams the XML representation of all derivates matching both selector and filter arguments. Derivates are loaded lazily, so you can abort the stream early without having to scan the entire repository. Positional Parameters String | Collection<String> selector optional - The selectors to search for. See the mcrids() function for details. String | Closure filter optional - An additional filter to apply after the selector. See the mcrobj() function for details. Returns a Stream of JDOM Document instances matching your arguments in repository default order. Apply an XSLT transform Function mcrxslt(source, ...stylesheet) Transforms the XML document source with the XSLT stylesheet and returns the result. Please Note: This function currently only sets up a simple environment for XSLT transformations. It can't - yet - handle MyCoRe stylesheets that need a more complex setup. Positional Parameters Document | MCRObject | MCRDerivate | MCRMODSWrapper | MCRObjectID | String source - The source XML document, which can be passed in a variety of formats. When you call this function with a String , there is a special logic in place: if the string is a syntactically valid MyCoRe Object ID, the Document referenced by it will be used as the source. If it is not a valid ID, the string's content itself will be parsed as an XML document. String stylesheet optional, repeatable - The names of the XSLT stylesheets to be applied. This function will resolve the names with MyCoRe's MCRXSLTransformer.getInstance() method, so the same naming conventions used there apply here. If you pass multiple instances of this parameter, the stylesheets will be applied in the same order. Optional Named Parameters Map<String, String> params = null - You can add some extra parameters that will be set during the XSLT transformation. The values from your MyCoRe configuration will always be set by default, as usual, and you don't have to specify them here explicitly. You can additionally use all the named parameters of the mcrdo() function to control the session environment for the XSLT transformation. Without any further parameters and in absence of a pre-existing session, the REPL's default admin session will be used. If this function is called from a session-context, the pre-existing session will be reused instead. Returns the transformed XML as a JDOM Document object. Interacting with XML Objects XML Mixins for org.jdom2.Document doc() - Returns the full XML of Document doc as a String . doc[] - Returns the structure of the root element of Document doc as a String . doc[xpath] - Returns the first match of the XPath query String xpath on Document doc . doc[[xpath]] - Returns all matches of the XPath query String xpath on Document doc as a list. doc << element - Sets the root element of Document doc to Element element . You can alternatively pass a String in XML syntax to have it converted to an Element automatically. doc.reload() - Reload Document doc from the repository in-place. doc.id - Returns the ID of the MyCoRe object contained in Document doc as a String . XML Mixins for org.jdom2.Element element() - Returns the full XML of Element element as a String . element[] - Returns the structure of Element element as a String . element[index] - Returns the child of Element element at position int index . element[xpath] - Returns the first match of the XPath query String xpath on Element element . element[[xpath]] - Returns all matches of the XPath query String xpath on Element element as a list. element << content - Sets the contents of Element element to Content | Attribute | String | Collection<Content | Attribute | String> content . If you pass String arguments in XML-like syntax (i.e. starting with < and ending with > ), they will automatically be converted to an Element . If you do not specify any namespaces in content , all your elements will inherit the namespace of element . Once you specify a single namespace, no automatic inheritance will be performed. element + content - Appends Content | Attribute | String | Collection<Content | Attribute | String> content to the contents of element . The + operator behaves somewhat unusually in that it performs this change in-place , contrary to the usual arithmetic plus operator. The rules for namespace inheritance and String conversion are the same as for the << operator. To remove an element, JDOM's builtin method Element.detach() may be used. XML Mixins for org.jdom2.Attribute attribute() - Returns the value of Attribute attribute as a String . attribute << value - Sets the value of Attribute attribute to String value . To remove an attribute, JDOM's builtin method Attribute.detach() may be used. XML Mixins for org.jdom2.Text text() - Returns the value of Text text as a String . text << value - Sets the contents of Text text to String value . text + value - Appends String value to the contents of Text text . The + operator behaves somewhat unusually in that it performs this change in-place , contrary to the usual arithmetic plus operator. To remove a text block, JDOM's builtin method Text.detach() may be used. XML Mixins for org.mycore.datamodel.metadata.MCRObject MCRObject also mirrors most of the mixins from org.jdom2.Document , except for those that change the XML. XML Mixins for org.mycore.datamodel.metadata.MCRDerivate MCRDerivate also mirrors most of the mixins from org.jdom2.Document , except for those that change the XML. XML Mixins for org.mycore.mods.MCRMODSWrapper mods.JDomDocument - Returns the entire Document behind the MCRMODSWrapper mods (i.e. including the parts outside of the MODS container). mods.createXML() - Returns the result of invoking createXML() on the wrapped MCRObject . MCRMODSWrapper also mirrors most of the mixins from org.jdom2.Document , except for those that change the XML. If you'd like to change a document's XML, you should use object returned by the mcrxml() function. Examples: // retrieving XML groovy:000> x = mcrxml(\"foo_mods_00000194\") ===> [Document: No DOCTYPE declaration, Root is [Element: <mycoreobject/>]] // inspecting first level structure groovy:000> x[] ===> [Element: <mycoreobject/>]: [[Text: ], [Element: <structure/>], [Text: ], [Element: <metadata/>], [Text: ], [Element: <service/>], [Text: ]] // XPath queries... groovy:000> x[\"//mods:title/text()\"] ===> [Text: An Example Doc] // ...or directly as a string groovy:000> x[\"//mods:title/text()\"]() ===> An Example Doc // dumping full XML text groovy:000> x[\"//mods:name\"]() ===> <mods:name xmlns:mods=\"http://www.loc.gov/mods/v3\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" type=\"personal\" xlink:type=\"simple\"> <mods:role> <mods:roleTerm authority=\"marcrelator\" type=\"code\">aut</mods:roleTerm> </mods:role> <mods:displayForm>Doe, John</mods:displayForm> <mods:nameIdentifier type=\"example\">foo@bar</mods:nameIdentifier> <mods:namePart type=\"family\">Doe</mods:namePart> <mods:namePart type=\"given\">John</mods:namePart> </mods:name> // updating an element with text content groovy:000> x[\"//mods:title\"] << \"New Title\" ===> [Element: <mods:title [Namespace: http://www.loc.gov/mods/v3]/>] groovy:000> x() [...] <mods:titleInfo xlink:type=\"simple\"> <mods:title>New Title</mods:title> </mods:titleInfo> [...] // adding a new child element, xml-like strings are auto-converted to xml with namespace inheritance groovy:000> x[\"//mods:mods\"] + \"<identifier type='doi'>10.5555/12345678</identifier>\" ===> [Element: <mods:mods [Namespace: http://www.loc.gov/mods/v3]/>] groovy:000> x[\"//mods:mods\"]() [...] <mods:identifier type=\"doi\">10.5555/12345678</mods:identifier> </mods:mods> // XSLT-transforming a document, overriding some parameters groovy:000> mcrxslt(\"foo_mods_00000001\", \"xsl/mods2oai_dc.xsl\", params:[WebApplicationBaseURL: \"https://example.org/\", ServletsBaseURL: \"https://example.org/\"]) ===> [Document: No DOCTYPE declaration, Root is [Element: <record [Namespace: http://www.openarchives.org/OAI/2.0/]/>]] groovy:000> _() ===> <record xmlns=\"http://www.openarchives.org/OAI/2.0/\"> [...] <dc:identifier>https://example.org/receive/foo_mods_00000001</dc:identifier> <dc:identifier>https://example.org/MCRZipServlet/foo_derivate_00000001</dc:identifier> [...] Changing documents Here are some functions that you can use to update a document's state in the repository. Update or create a document Function mcrsave(...object) Creates or updates documents in the repository. The changes will be performed in a transaction. If the saved documents were present in one of MyCoRe's caches, those entries will automatically be invalidated. Positional Parameters Document | MCRObject | MCRDerivate | MCRMODSWrapper | Collection<> object repeatable - The documents to save. Pre-existing documents will be updated and new documents will be created. You may optionally pass your documents wrapped in a Collection . Optional Named Parameters Boolean jointransaction = true - Controls whether we will join an existing transaction. If set to false and mcrsave() is called from an ongoing transaction, an exception will be raised. Boolean reload = false - You may optionally trigger an in-place reload for all saved documents from the repository after they were persisted. This is to ensure that your variables reflect the actual state of the document on-disk - including changes added by event-handlers triggered when saving. The default is to not reload the documents (which is faster, but can cause problems if you try to save your not-reloaded variables a second time). Boolean update = true - Set this to false to make sure that all your documents were actually new and not pre-existing. In the case of pre-existing documents, an exception will be raised. By default, the pre-existing documents would be updated with your new version. You can additionally use all the named parameters of the mcrsession() function to control the session environment. Without any further parameters and in absence of a pre-existing session, the REPL's default admin session will be used to start and commit a new transaction. If the call is from a session-context, the pre-existing session will be reused. Returns nothing. Show differences between revisions of a document Function mcrdiff(old, updated) Shows the XML-level differences between two versions of a document. Positional Parameters Document | MCRObject | MCRDerivate | MCRMODSWrapper old optional - The old version of the document. If omitted, it will automatically be fetched from the repository by the id of the new document. Document | MCRObject | MCRDerivate | MCRMODSWrapper updated - The new version of the document. Returns a String representation of the differences in unified diff format, or null if both versions are identical. Invalidate a document in MyCoRe's caches Function mcrinvalidate(...id) Invalidates the specified documents in MyCoRe's Creator Cache and Permission Caches. This is required to make sure that changes you made to the documents are properly reflected in the system. If you use mcrsave() to update documents, this is done for you automatically and you do not have to call mcrinvalidate() explicitly. Positional Parameters Document | MCRObject | MCRDerivate | MCRMODSWrapper | MCRObjectID | String | Collection<> id repeatable - The documents whose state you want to invalidate in the caches. In addition to the usual formats, you can also pass an ID as a String, or a Collection of these types. Returns nothing. Examples: groovy:000> x=mcrxml(\"foo_mods_00000229\") ===> [Document: No DOCTYPE declaration, Root is [Element: <mycoreobject/>]] // let's change the document a bit groovy:000> x[\"//mods:title\"] << \"The new title.\" ===> [Element: <mods:title [Namespace: http://www.loc.gov/mods/v3]/>] groovy:000> x[\"//mods:physicalDescription\"].detach() ===> [Element: <mods:physicalDescription [Namespace: http://www.loc.gov/mods/v3]/>] groovy:000> x[\"//mods:mods\"] + \"<identifier type='urn'>urn:uuid:c8b34090-6cd8-11ee-b962-0242ac120002</identifier>\" ===> [Element: <mods:mods [Namespace: http://www.loc.gov/mods/v3]/>] // show the differences in the xml before saving groovy:000> mcrdiff(x) ===> --- old +++ updated @@ -24,3 +24,3 @@ <mods:titleInfo xlink:type=\"simple\"> - <mods:title>Upload Test.</mods:title> + <mods:title>The new title.</mods:title> </mods:titleInfo> @@ -55,6 +55,3 @@ </mods:name> - <mods:physicalDescription> - <mods:note xlink:type=\"simple\">Datenstruktur 1&#xD; -Datenstruktur 2</mods:note> - </mods:physicalDescription> + <mods:identifier type=\"urn\">urn:uuid:c8b34090-6cd8-11ee-b962-0242ac120002</mods:identifier> </mods:mods> // saving the changes groovy:000> mcrsave(x, reload: true) ===> null // note that the object was auto-reloaded in-place, reflecting all the changes applied during saving groovy:000> x[\"//servdate[@type='modifydate']/text()\"]() ===> 2023-10-17T11:13:31.449Z Solr Queries Solr Query, retrieving all matches Function mcrsolr(query) Submit a query to a Solr server and return all results. Positional Parameters String query - The Solr query in standard Solr syntax . Optional Named Parameters HttpSolrClient client = MCRSolrClientFactory.mainSolrClient - The Solr client to use. If omitted, use MyCoRe's main client. String fl - Fields to return in standard Solr syntax Integer rows = Integer.MAX_VALUE - The number of matches to return. If omitted, this number is practically unlimited, so all matches will be returned. String sort - Sorting conditions in standard Solr syntax . Integer start = 0 - Include results starting with this position in the result set. If omitted, we will start at the beginning. Returns the QueryResponse object containing your results. SOLR Query, retrieving IDs of all matches Function mcrsolrids(query) Submit a query to a Solr server and return the MyCoRe IDs of all matching documents. Positional Parameters String query - The Solr query in standard Solr syntax . Optional Named Parameters HttpSolrClient client = MCRSolrClientFactory.mainSolrClient - The Solr client to use. If omitted, use MyCoRe's main client. Integer rows = Integer.MAX_VALUE - The number of matches to return. If omitted, this number is practically unlimited, so all matches will be returned. String sort - Sorting conditions in standard Solr syntax . Integer start = 0 - Include results starting with this position in the result set. If omitted, we will start at the beginning. Returns a List<String> of MyCoRe IDs matching your query. SOLR Query, retrieving first match only Function mcrsolrfirst(query) Submit a query to a Solr server and return the first matching result. Positional Parameters String query - The Solr query in standard Solr syntax . Optional Named Parameters HttpSolrClient client = MCRSolrClientFactory.mainSolrClient - The Solr client to use. If omitted, use MyCoRe's main client. String fl - Fields to return in standard Solr syntax String sort - Sorting conditions in standard Solr syntax . Integer start = 0 - Return the result at this position in the result set. If omitted, we will return the first result. Returns the SolrDocument of your query's first match, or null if there were no qualifying documents. SOLR Query, streaming matches Function mcrsolrstream(query) Submit a query to a Solr server and stream all the results incrementally, so they may be processed while the query is still active. You can cancel streaming queries before all results were transferred if it is convenient for you. Positional Parameters String query - The Solr query in standard Solr syntax . Optional Named Parameters Integer chunksize = 1000 - Size of each chunk that will be transferred vom server to client. HttpSolrClient client = MCRSolrClientFactory.mainSolrClient - The Solr client to use. If omitted, use MyCoRe's main client. String fl - Fields to return in standard Solr syntax Boolean parallel = false - If enabled, this function will return a parallel stream, which may allows for faster processing at the price of losing ordering information. Defaults to false , returning a sequential, ordered stream. String sort - Sorting conditions in standard Solr syntax . Returns a Stream<SolrDocument> containing your results. Interacting with Solr Documents Mixins for org.apache.solr.common.SolrDocument Because SolrDocument implements Java's Map interface, you get access to all of Groovy's convenience methods for Maps . Especially noteworthy are the following: solrdoc.field - Returns the value of the literal expression field contained in the Solr result SolrDocument solrdoc . Does not support field names containing special characters. solrdoc[field] - Returns the value of the String field contained in the Solr result SolrDocument solrdoc . This method also supports field names containing special characters. Examples: // find the ids of all MODS documents with \"Test\" in the title, recently modified documents first groovy:000> mcrsolrids(\"mods.title:*Test*\", sort:\"modified desc\") ===> [foo_mods_00000292, foo_mods_00000289, foo_mods_00000270, [...] // retrieve author names' of a single publication from the Solr server groovy:000> mcrsolrfirst(\"id:foo_mods_00000252\")[\"mods.name\"].join(\"; \") ===> Blaub\u00e4r, K\u00e4ptn; Bl\u00f6d, Hein // check for MyCoRe objects that exist in the Solr, but not the repository groovy:000> `mcrsolrstream(\"objectKind:mycoreobject\", fl: \"id\").map(x -> new MCRObjectID(x.id)) .filter(x -> !MCRXMLMetadataManager.instance().exists(x)).toList()` ===> [] Sessions, Transactions, Jobs The REPL's MyCoRe support functions handle sessions and transactions automatically for you. If you'd like to perform longer-running batch edits, or would like to interact directly with MyCoRe's classes within a session context, there are additional functions available that enable you to manage sessions yourself. Create a MyCoRe session Function mcrsession() Creates a new MyCoRe session without activating it. If invoked without parameters, it will return a default admin-level session which is associated with your current REPL session. Optional Named Parameters MCRSession session - Use this pre-existing session. String sessionid - Use the pre-existing session identified by this id. MCRUser user - Create a new session belonging to this user. String userid - Create a new session belonging to the user identified by this id. Returns the MCRSession you requested. Run code in a MyCoRe session / transaction Function mcrdo(closure) Executes a parameterless Groovy closure inside a MyCoRe session and optionally also a transaction. The session is transparently entered and left at entry and exit. The transaction will automatically be committed on success and rolled back if an exception is thrown. Positional Parameters Closure closure - The parameterless Groovy closure that will be executed. Optional Named Parameters Boolean join = false - Join the active outer session instead of creating a new one. In this case, this function will not release the session on exit. Boolean quiet = false - Silence the warning that is emitted when running with an active outer session and join = false . Boolean transaction = false - Create a new transaction and commit it on exit, or roll it back if an exception is thrown. You can additionally use all the named parameters of the mcrsession() function to control the session that will be created. Without any further parameters, the REPL's default admin session will be used. Returns the return value of your closure . Create a new job Function mcrjob(closure) This is a MyCoRe-enhanced version of the REPL's universal job() function . The major additional features that it provides are session- and transaction-management as well as integration with MyCoRe's processing infrastructure. You can view the progress of an mcrjob() in MyCoRe's web interface. Positional Parameters Closure closure - The closure to execute. See job() for details. Optional Named Parameters Boolean convert = false - Because the job's input parameter must be serializable, you can't use MCRObject , MCRDerivate or MCRMODSWrapper type objects as input. When this parameter is enabled, these types of objects will automatically be converted to JDOM's Document class, which can be used instead. Note that it is generally recommended to pass documents' IDs as inputs and not the documents itself. ThreadFactory threadfactory - This parameter analogous to its version in job() , with the added difference that mcrjob() uses it internally to manage MyCoRe session. You should refrain from setting it when using mcrjob() , or lose session and transaction handling features. Boolean transaction = false - Execute the job inside a MyCoRe transaction. It will be auto-committed if less than transactionerrors errors happened, or rolled back otherwise. Integer transactionerrors = 1 - If you set transaction , and the number of failed inputs reaches this limit, the entire job will be cancelled and the transaction rolled back. By default, this will happen on the first error. You can additionally use all the named parameters of the job() function as well as the the mcrsession() to tweak job processing and its MyCoRe session environment. If you do not specify any session parameters, your closure will run inside a newly created admin-level session. Returns the ReplJob that was created. Related Classes: REPLJob , REPLJobCallbackAutoTune provide additional functionality related to job control. Examples: // sessions can be nested groovy:000> mcrdo({ groovy:001> println(MCRSessionMgr.currentSession) groovy:002> mcrdo({ println(MCRSessionMgr.currentSession) }, userid: \"editor\", quiet: true) groovy:003> println(MCRSessionMgr.currentSession) groovy:004> }) MCRSession[c86a247f-ef95-4a20-853f-d27e9a935dc9,user:'administrator',ip:127.0.0.1] MCRSession[17a156c4-613c-4453-8ab7-71302a58bed0,user:'editor',ip:127.0.0.1] MCRSession[c86a247f-ef95-4a20-853f-d27e9a935dc9,user:'administrator',ip:127.0.0.1] // bulk editing in a transaction. for a speedup, try adding \"concurrency: 5\" to the parameters // THIS EXAMPLE WILL MAKE PERMANENT CHANGES TO YOUR DOCUMENTS groovy:000> ids = mcrsolrids(\"mods.title:*Test*\") ===> [foo_mods_00000272, foo_mods_00000273, foo_mods_00000274, [...] groovy:000> mcrjob({ id, job -> groovy:001> def doc = mcrxml(id) groovy:002> def title = doc[\"//mods:title\"] groovy:003> title << title.text.replaceAll(/(?i)Test/, \"Bork Bork Bork\") groovy:004> mcrsave(doc) groovy:005> return title.text groovy:006> }, inputs: ids, transaction: true, progress: true) ===> 20231017-125903-180455901 (Job 20231017-125903-180455901) [2023-10-17 12:59:03] INFO Job 20231017-125903-180455901: 4% done, eta 52s [...] MyCoRe's native CLI MyCoRe's native CLI commands can be invoked from the REPL. Some of MyCoRe's CLI commands implicitly assume that there is only one CLI session active globally, so do not execute multiple commands in parallel (especially not in a parallelized job). Use MyCoRe's native CLI Function mcrcli(command) The REPL integrates MyCoRe's native CLI, which you can access from the SSH session. Please Note: Some of MyCoRe's CLI commands implicitly assume that there is only one CLI session active globally, so do not execute multiple commands in parallel (especially not in a parallelized job). Positional Parameters String command - The command to execute, exactly as you would type it in MyCoRe's native CLI. Optional Named Parameters Boolean errors_from_log = true - If enabled, log messages with the level ERROR or above will be treated as a failed CLI command. Many MyCoRe CLI commands do not throw exceptions when an error occurs, so this is necessary to detect failure conditions. MCRSession mcrsession = <the REPL's default admin session> - You can optionally specify a MyCoRe session that your command will run in. If omitted, the REPL's default administrator-level session will be used. Returns true if there were no errors, false if there were errors. Further details are available in the cauCLIResult MyCoRe session variable (access it e.g. by mcrsession().get(\"cauCLIResult\") ). Shell Command :mcrcli [command] :M [command] This is the shell command version of the mcrcli() function. It provides identical functionality, and is more convenient to work with since it does not require you to quote your command. Please Note: for technical reasons, repeated whitespace characters in your command string will be merged into a single space - even within quotes (which will be considered part of your command). If this is a problem, you should use the mcrcli() function instead. Returns true if there were no errors, false if there were errors. Further details are available in the cauCLIResult MyCoRe session variable (access it e.g. by mcrsession().get(\"cauCLIResult\") ). Examples: // let's select some documents groovy:000> :M select objects with solr query id:foo_mods_00000001 in core main Syntax matched (executed): select objects with solr query {0} in core {1} 1 objects selected CLI finished successfully: 1 commands Hint: retrieve detailed results from the \"cauCLIResult\" session variable, e.g.: mcrsession().get(\"cauCLIResult\") ===> true ===> true groovy:000> :M list selected Syntax matched (executed): list selected List selected MCRObjects foo_mods_00000001 CLI finished successfully: 1 commands Hint: retrieve detailed results from the \"cauCLIResult\" session variable, e.g.: mcrsession().get(\"cauCLIResult\") ===> true ===> true // let's now intentionally trigger an error groovy:000> :M set main file of invalid_id to foo Syntax matched (executed): set main file of {0} to {1} invalid_id is not valid. ERROR: Command 'set main file of invalid_id to foo' failed java.lang.RuntimeException: invalid_id is not valid. CLI finished with 1 errors Hint: retrieve detailed results from the \"cauCLIResult\" session variable, e.g.: mcrsession().get(\"cauCLIResult\") ERROR java.lang.RuntimeException: invalid_id is not valid. at groovysh_evaluate.mcrcli (groovysh_evaluate:31) at groovysh_evaluate.mcrcli (groovysh_evaluate) // we can retrieve detailed results from the session variable groovy:000> mcrsession().get(\"cauCLIResult\") ===> [[cmd:set main file of invalid_id to foo, log:Syntax matched (executed): set main file of {0} to {1} invalid_id is not valid. , error:java.lang.RuntimeException: invalid_id is not valid., timestamp:2023-10-10T11:19:39.861122497Z]] Compiling The REPL will normally compile your Groovy sources when the target application starts. If you want to compile code dynamically at runtime, there is a support function available for you. Compile Groovy sources Function mcrcompile(path) Compile the Groovy sources at the specified path and load them into a suitable classloader. This is a specialized version of the generic compile() function which will automatically use the proper ClassLoader and class path of your servlet container. Positional Parameters Path | File | String path - The location of the sources to compile. If you pass a directory, all .groovy files below it will be compiled as one coherent unit. Optional Named Parameters ClassLoader classloader = <MyCoRe's classloader> - The ClassLoader in which the generated classed should be put. Will default to MyCoRe's ClassLoader. String classpath = <MyCoRe's classpath> - The class path to use when locating targets of the @Patches annotation. Defaults to the MyCoRe's classpath. Returns the GroovySourceDirectory with the results of the compilation. Related Classes: GroovySourceDirectory provides additional functionality related to compilation.","title":"MyCoRe Integration"},{"location":"mycore/#mycore-integration","text":"If you compile cau-repl with GPL code enabled (the -gpl version), the REPL supports some additional command that provide better integration with MyCoRe than the default generic version. As a MyCoRe user, you should install the REPL as a MyCoRe plugin . In this section you will find outlined some additional features that you can use.","title":"MyCoRe Integration"},{"location":"mycore/#retrieving-documents","text":"There are numerous functions available for retrieving Documents from you repository. If you intend on working with a document's XML structure, please refer to the Working with XML section, which describes the functions related to those kinds of tasks. Get document IDs Function mcrids(...selector) This function returns the IDs of all documents (not including derivates) that match the given selector . Positional Parameters String | Collection<String> selector optional, repeatable - The selectors to search for. Each selector parameter instance can either be a String or a Collection of multiple selectors. Valid selectors are MyCoRe type strings (\" mods \"), base strings (\" foo_mods \") and strings representing MyCoRe IDs (\" foo_mods_00000001 \"). If you omit this parameter, all documents' IDs (excluding derivates) will be returned. Returns a list of the MCRObjectID IDs from your repository's documents matching any of your selectors. Get derivate IDs Function mcrderids(...selector) This function returns the IDs of all derivates that match the given selector . Positional Parameters String | Collection<String> selector optional, repeatable - The selectors to search for. Each selector parameter instance can either be a String or a Collection of multiple selectors. Valid selectors are MyCoRe type strings (\" derivate \"), base strings (\" foo_derivate \") and strings representing MyCoRe IDs (\" foo_derivate_00000001 \"). If you omit this parameter, all derivates' IDs will be returned. Returns a list of the MCRObjectID IDs from your repository's derivates matching any of your selectors. Retrieving documents Function mcrobj(selector, filter) This function returns all documents matching both selector and filter arguments. Positional Parameters String | Collection<String> selector optional - The selectors to search for. See the mcrids() function for details. String | Closure filter optional - An additional filter to apply after the selector. It can either be an XPath string (returning only those documents for which its result is not empty), or a Closure (returning only those documents for which its results is truthy). If you omit this parameter, exactly the documents matching the selector will be returned. Returns the list of MCRObjects matching your criteria. In the special case where your selector is an MCRObjectID or a valid MyCoRe ID in string form, the single result is automatically unwrapped and returned as an MCRObject without a list (or null if not matched). Retrieving MODS documents Function mcrmods(selector, filter) This function returns all MODS documents matching both selector and filter arguments. Positional Parameters String | Collection<String> selector = \"mods\" optional - The selectors to search for. See the mcrids() function for details. String | Closure filter optional - An additional filter to apply after the selector. See the mcrobj() function for details. Returns the list of MCRMODSWrapper objects matching your criteria. In the special case where your selector is an MCRObjectID or a valid MyCoRe ID in string form, the single result is automatically unwrapped and returned as an MCRMODSWrapper without a list (or null if not matched). Retrieving derivates Function mcrder(selector, filter) This function returns all derivates matching both selector and filter arguments. Positional Parameters String | Collection<String> selector optional - The selectors to search for. See the mcrderids() function for details. String | Closure filter optional - An additional filter to apply after the selector. See the mcrobj() function for details. Returns the list of MCRDerivate objects matching your criteria. In the special case where your selector is an MCRObjectID or a valid MyCoRe ID in string form, the single result is automatically unwrapped and returned as an MCRDerivate without a list (or null if not matched). Streaming documents Function mcrstream(selector, filter) Streams all documents matching both selector and filter arguments. Documents are loaded lazily, so you can abort the stream early without having to scan the entire repository. Positional Parameters String | Collection<String> selector optional - The selectors to search for. See the mcrids() function for details. String | Closure filter optional - An additional filter to apply after the selector. See the mcrobj() function for details. Returns a Stream of MCRObject instances matching your arguments in repository default order. Streaming MODS documents Function mcrmodsstream(filter, selector) Streams all MODS documents matching both selector and filter arguments. Documents are loaded lazily, so you can abort the stream early without having to scan the entire repository. Positional Parameters String | Collection<String> selector = \"mods\" optional - The selectors to search for. See the mcrids() function for details. String | Closure filter optional - An additional filter to apply after the selector. See the mcrobj() function for details. Returns a Stream of MCRMODSWrapper instances matching your arguments in repository default order. Streaming derivates Function mcrderstream(filter, selector) Streams all derivates matching both selector and filter arguments. Derivates are loaded lazily, so you can abort the stream early without having to scan the entire repository. Positional Parameters String | Collection<String> selector optional - The selectors to search for. See the mcrderids() function for details. String | Closure filter optional - An additional filter to apply after the selector. See the mcrobj() function for details. Returns a Stream of MCRDerivate instances matching your arguments in repository default order. Retrieving derivates' files Function mcrderfiles(...selector) Retrieve all files of the derivate(s) matching the selector . Positional Parameters String | Collection<String> selector optional, repeatable - The selectors to search for. See the mcrderids() function for details. Returns in a single list: for each file a Map containing the keys derid (as MCRObjectID ), path (as MCRPath ) and attributes (as MCRFileAttributes ). The same functionality is also mirrored for Derivate instances: File Mixins for org.mycore.datamodel.metadata.MCRDerivate derivate.files invoked on an MCRDerivate instance also returns the derivate's files in the same format as mcrderfiles() . Examples: // generating a list of all \"foo_mods\" documents groovy:000> mcrobj(\"foo_mods\") ===> [foo_mods_00000001, foo_mods_00000002, foo_mods_00000003, [...] // finding the first document with a maindoc named 'sample.pdf' groovy:000> mcrstream(null, \"/mycoreobject/structure/derobjects/derobject[maindoc='sample.pdf']\").findFirst() ===> Optional[foo_mods_00000101] // generating a list of all MODS documents that were created by the admin user groovy:000> mcrmods(\"mods\", {it.getServiceFlag(\"createdby\").equals(\"administrator\")}) ===> [MCRMODSWrapper(foo_mods_00000004), MCRMODSWrapper(foo_mods_00000005), MCRMODSWrapper(foo_mods_00000009), [...] // find all derivates' files whose on-disk md5 checksum does not match the on-record checksum groovy:000> mcrderfiles().findAll{ !it.path.toPhysicalPath().toFile().bytes.md5().equals(it.attributes.md5sum) } ===> []","title":"Retrieving Documents"},{"location":"mycore/#working-with-xml","text":"There are specialized functions available for retrieving documents if you plan to work with their XML structure directly. In contrast to the functions that were introduced in the last section, these XML-centric functions allow you to change the XML directly on the element-level and write your changes back to the repository after you are done. Retrieving documents' XML Function mcrxml(selector, filter) Retrieves the XML data of the documents matching selector and filter . Positional Parameters String | Collection<String> selector optional - The selectors to search for. See the mcrids() function for details. String | Closure filter optional - An additional filter to apply after the selector. See the mcrobj() function for details. Returns the list of JDOM Document objects matching your criteria. In the special case where your selector is an MCRObjectID or a valid MyCoRe ID in string form, the single result is automatically unwrapped and returned as a JDOM document without a list (or null if not matched). Retrieving derivates' XML Function mcrderxml(selector, filter) Retrieves the XML data of the derivates matching selector and filter . Positional Parameters String | Collection<String> selector optional - The selectors to search for. See the mcrderids() function for details. String | Closure filter optional - An additional filter to apply after the selector. See the mcrobj() function for details. Returns the list of JDOM Document objects matching your criteria. In the special case where your selector is an MCRObjectID or a valid MyCoRe ID in string form, the single result is automatically unwrapped and returned as a JDOM document without a list (or null if not matched). Streaming documents' XML Function mcrstreamxml(selector, filter) Streams the XML representation of all documents matching both selector and filter arguments. Documents are loaded lazily, so you can abort the stream early without having to scan the entire repository. Positional Parameters String | Collection<String> selector optional - The selectors to search for. See the mcrids() function for details. String | Closure filter optional - An additional filter to apply after the selector. See the mcrobj() function for details. Returns a Stream of JDOM Document instances matching your arguments in repository default order. Streaming derivates' XML Function mcrderstreamxml(selector, filter) Streams the XML representation of all derivates matching both selector and filter arguments. Derivates are loaded lazily, so you can abort the stream early without having to scan the entire repository. Positional Parameters String | Collection<String> selector optional - The selectors to search for. See the mcrids() function for details. String | Closure filter optional - An additional filter to apply after the selector. See the mcrobj() function for details. Returns a Stream of JDOM Document instances matching your arguments in repository default order. Apply an XSLT transform Function mcrxslt(source, ...stylesheet) Transforms the XML document source with the XSLT stylesheet and returns the result. Please Note: This function currently only sets up a simple environment for XSLT transformations. It can't - yet - handle MyCoRe stylesheets that need a more complex setup. Positional Parameters Document | MCRObject | MCRDerivate | MCRMODSWrapper | MCRObjectID | String source - The source XML document, which can be passed in a variety of formats. When you call this function with a String , there is a special logic in place: if the string is a syntactically valid MyCoRe Object ID, the Document referenced by it will be used as the source. If it is not a valid ID, the string's content itself will be parsed as an XML document. String stylesheet optional, repeatable - The names of the XSLT stylesheets to be applied. This function will resolve the names with MyCoRe's MCRXSLTransformer.getInstance() method, so the same naming conventions used there apply here. If you pass multiple instances of this parameter, the stylesheets will be applied in the same order. Optional Named Parameters Map<String, String> params = null - You can add some extra parameters that will be set during the XSLT transformation. The values from your MyCoRe configuration will always be set by default, as usual, and you don't have to specify them here explicitly. You can additionally use all the named parameters of the mcrdo() function to control the session environment for the XSLT transformation. Without any further parameters and in absence of a pre-existing session, the REPL's default admin session will be used. If this function is called from a session-context, the pre-existing session will be reused instead. Returns the transformed XML as a JDOM Document object. Interacting with XML Objects XML Mixins for org.jdom2.Document doc() - Returns the full XML of Document doc as a String . doc[] - Returns the structure of the root element of Document doc as a String . doc[xpath] - Returns the first match of the XPath query String xpath on Document doc . doc[[xpath]] - Returns all matches of the XPath query String xpath on Document doc as a list. doc << element - Sets the root element of Document doc to Element element . You can alternatively pass a String in XML syntax to have it converted to an Element automatically. doc.reload() - Reload Document doc from the repository in-place. doc.id - Returns the ID of the MyCoRe object contained in Document doc as a String . XML Mixins for org.jdom2.Element element() - Returns the full XML of Element element as a String . element[] - Returns the structure of Element element as a String . element[index] - Returns the child of Element element at position int index . element[xpath] - Returns the first match of the XPath query String xpath on Element element . element[[xpath]] - Returns all matches of the XPath query String xpath on Element element as a list. element << content - Sets the contents of Element element to Content | Attribute | String | Collection<Content | Attribute | String> content . If you pass String arguments in XML-like syntax (i.e. starting with < and ending with > ), they will automatically be converted to an Element . If you do not specify any namespaces in content , all your elements will inherit the namespace of element . Once you specify a single namespace, no automatic inheritance will be performed. element + content - Appends Content | Attribute | String | Collection<Content | Attribute | String> content to the contents of element . The + operator behaves somewhat unusually in that it performs this change in-place , contrary to the usual arithmetic plus operator. The rules for namespace inheritance and String conversion are the same as for the << operator. To remove an element, JDOM's builtin method Element.detach() may be used. XML Mixins for org.jdom2.Attribute attribute() - Returns the value of Attribute attribute as a String . attribute << value - Sets the value of Attribute attribute to String value . To remove an attribute, JDOM's builtin method Attribute.detach() may be used. XML Mixins for org.jdom2.Text text() - Returns the value of Text text as a String . text << value - Sets the contents of Text text to String value . text + value - Appends String value to the contents of Text text . The + operator behaves somewhat unusually in that it performs this change in-place , contrary to the usual arithmetic plus operator. To remove a text block, JDOM's builtin method Text.detach() may be used. XML Mixins for org.mycore.datamodel.metadata.MCRObject MCRObject also mirrors most of the mixins from org.jdom2.Document , except for those that change the XML. XML Mixins for org.mycore.datamodel.metadata.MCRDerivate MCRDerivate also mirrors most of the mixins from org.jdom2.Document , except for those that change the XML. XML Mixins for org.mycore.mods.MCRMODSWrapper mods.JDomDocument - Returns the entire Document behind the MCRMODSWrapper mods (i.e. including the parts outside of the MODS container). mods.createXML() - Returns the result of invoking createXML() on the wrapped MCRObject . MCRMODSWrapper also mirrors most of the mixins from org.jdom2.Document , except for those that change the XML. If you'd like to change a document's XML, you should use object returned by the mcrxml() function. Examples: // retrieving XML groovy:000> x = mcrxml(\"foo_mods_00000194\") ===> [Document: No DOCTYPE declaration, Root is [Element: <mycoreobject/>]] // inspecting first level structure groovy:000> x[] ===> [Element: <mycoreobject/>]: [[Text: ], [Element: <structure/>], [Text: ], [Element: <metadata/>], [Text: ], [Element: <service/>], [Text: ]] // XPath queries... groovy:000> x[\"//mods:title/text()\"] ===> [Text: An Example Doc] // ...or directly as a string groovy:000> x[\"//mods:title/text()\"]() ===> An Example Doc // dumping full XML text groovy:000> x[\"//mods:name\"]() ===> <mods:name xmlns:mods=\"http://www.loc.gov/mods/v3\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" type=\"personal\" xlink:type=\"simple\"> <mods:role> <mods:roleTerm authority=\"marcrelator\" type=\"code\">aut</mods:roleTerm> </mods:role> <mods:displayForm>Doe, John</mods:displayForm> <mods:nameIdentifier type=\"example\">foo@bar</mods:nameIdentifier> <mods:namePart type=\"family\">Doe</mods:namePart> <mods:namePart type=\"given\">John</mods:namePart> </mods:name> // updating an element with text content groovy:000> x[\"//mods:title\"] << \"New Title\" ===> [Element: <mods:title [Namespace: http://www.loc.gov/mods/v3]/>] groovy:000> x() [...] <mods:titleInfo xlink:type=\"simple\"> <mods:title>New Title</mods:title> </mods:titleInfo> [...] // adding a new child element, xml-like strings are auto-converted to xml with namespace inheritance groovy:000> x[\"//mods:mods\"] + \"<identifier type='doi'>10.5555/12345678</identifier>\" ===> [Element: <mods:mods [Namespace: http://www.loc.gov/mods/v3]/>] groovy:000> x[\"//mods:mods\"]() [...] <mods:identifier type=\"doi\">10.5555/12345678</mods:identifier> </mods:mods> // XSLT-transforming a document, overriding some parameters groovy:000> mcrxslt(\"foo_mods_00000001\", \"xsl/mods2oai_dc.xsl\", params:[WebApplicationBaseURL: \"https://example.org/\", ServletsBaseURL: \"https://example.org/\"]) ===> [Document: No DOCTYPE declaration, Root is [Element: <record [Namespace: http://www.openarchives.org/OAI/2.0/]/>]] groovy:000> _() ===> <record xmlns=\"http://www.openarchives.org/OAI/2.0/\"> [...] <dc:identifier>https://example.org/receive/foo_mods_00000001</dc:identifier> <dc:identifier>https://example.org/MCRZipServlet/foo_derivate_00000001</dc:identifier> [...]","title":"Working with XML"},{"location":"mycore/#changing-documents","text":"Here are some functions that you can use to update a document's state in the repository. Update or create a document Function mcrsave(...object) Creates or updates documents in the repository. The changes will be performed in a transaction. If the saved documents were present in one of MyCoRe's caches, those entries will automatically be invalidated. Positional Parameters Document | MCRObject | MCRDerivate | MCRMODSWrapper | Collection<> object repeatable - The documents to save. Pre-existing documents will be updated and new documents will be created. You may optionally pass your documents wrapped in a Collection . Optional Named Parameters Boolean jointransaction = true - Controls whether we will join an existing transaction. If set to false and mcrsave() is called from an ongoing transaction, an exception will be raised. Boolean reload = false - You may optionally trigger an in-place reload for all saved documents from the repository after they were persisted. This is to ensure that your variables reflect the actual state of the document on-disk - including changes added by event-handlers triggered when saving. The default is to not reload the documents (which is faster, but can cause problems if you try to save your not-reloaded variables a second time). Boolean update = true - Set this to false to make sure that all your documents were actually new and not pre-existing. In the case of pre-existing documents, an exception will be raised. By default, the pre-existing documents would be updated with your new version. You can additionally use all the named parameters of the mcrsession() function to control the session environment. Without any further parameters and in absence of a pre-existing session, the REPL's default admin session will be used to start and commit a new transaction. If the call is from a session-context, the pre-existing session will be reused. Returns nothing. Show differences between revisions of a document Function mcrdiff(old, updated) Shows the XML-level differences between two versions of a document. Positional Parameters Document | MCRObject | MCRDerivate | MCRMODSWrapper old optional - The old version of the document. If omitted, it will automatically be fetched from the repository by the id of the new document. Document | MCRObject | MCRDerivate | MCRMODSWrapper updated - The new version of the document. Returns a String representation of the differences in unified diff format, or null if both versions are identical. Invalidate a document in MyCoRe's caches Function mcrinvalidate(...id) Invalidates the specified documents in MyCoRe's Creator Cache and Permission Caches. This is required to make sure that changes you made to the documents are properly reflected in the system. If you use mcrsave() to update documents, this is done for you automatically and you do not have to call mcrinvalidate() explicitly. Positional Parameters Document | MCRObject | MCRDerivate | MCRMODSWrapper | MCRObjectID | String | Collection<> id repeatable - The documents whose state you want to invalidate in the caches. In addition to the usual formats, you can also pass an ID as a String, or a Collection of these types. Returns nothing. Examples: groovy:000> x=mcrxml(\"foo_mods_00000229\") ===> [Document: No DOCTYPE declaration, Root is [Element: <mycoreobject/>]] // let's change the document a bit groovy:000> x[\"//mods:title\"] << \"The new title.\" ===> [Element: <mods:title [Namespace: http://www.loc.gov/mods/v3]/>] groovy:000> x[\"//mods:physicalDescription\"].detach() ===> [Element: <mods:physicalDescription [Namespace: http://www.loc.gov/mods/v3]/>] groovy:000> x[\"//mods:mods\"] + \"<identifier type='urn'>urn:uuid:c8b34090-6cd8-11ee-b962-0242ac120002</identifier>\" ===> [Element: <mods:mods [Namespace: http://www.loc.gov/mods/v3]/>] // show the differences in the xml before saving groovy:000> mcrdiff(x) ===> --- old +++ updated @@ -24,3 +24,3 @@ <mods:titleInfo xlink:type=\"simple\"> - <mods:title>Upload Test.</mods:title> + <mods:title>The new title.</mods:title> </mods:titleInfo> @@ -55,6 +55,3 @@ </mods:name> - <mods:physicalDescription> - <mods:note xlink:type=\"simple\">Datenstruktur 1&#xD; -Datenstruktur 2</mods:note> - </mods:physicalDescription> + <mods:identifier type=\"urn\">urn:uuid:c8b34090-6cd8-11ee-b962-0242ac120002</mods:identifier> </mods:mods> // saving the changes groovy:000> mcrsave(x, reload: true) ===> null // note that the object was auto-reloaded in-place, reflecting all the changes applied during saving groovy:000> x[\"//servdate[@type='modifydate']/text()\"]() ===> 2023-10-17T11:13:31.449Z","title":"Changing documents"},{"location":"mycore/#solr-queries","text":"Solr Query, retrieving all matches Function mcrsolr(query) Submit a query to a Solr server and return all results. Positional Parameters String query - The Solr query in standard Solr syntax . Optional Named Parameters HttpSolrClient client = MCRSolrClientFactory.mainSolrClient - The Solr client to use. If omitted, use MyCoRe's main client. String fl - Fields to return in standard Solr syntax Integer rows = Integer.MAX_VALUE - The number of matches to return. If omitted, this number is practically unlimited, so all matches will be returned. String sort - Sorting conditions in standard Solr syntax . Integer start = 0 - Include results starting with this position in the result set. If omitted, we will start at the beginning. Returns the QueryResponse object containing your results. SOLR Query, retrieving IDs of all matches Function mcrsolrids(query) Submit a query to a Solr server and return the MyCoRe IDs of all matching documents. Positional Parameters String query - The Solr query in standard Solr syntax . Optional Named Parameters HttpSolrClient client = MCRSolrClientFactory.mainSolrClient - The Solr client to use. If omitted, use MyCoRe's main client. Integer rows = Integer.MAX_VALUE - The number of matches to return. If omitted, this number is practically unlimited, so all matches will be returned. String sort - Sorting conditions in standard Solr syntax . Integer start = 0 - Include results starting with this position in the result set. If omitted, we will start at the beginning. Returns a List<String> of MyCoRe IDs matching your query. SOLR Query, retrieving first match only Function mcrsolrfirst(query) Submit a query to a Solr server and return the first matching result. Positional Parameters String query - The Solr query in standard Solr syntax . Optional Named Parameters HttpSolrClient client = MCRSolrClientFactory.mainSolrClient - The Solr client to use. If omitted, use MyCoRe's main client. String fl - Fields to return in standard Solr syntax String sort - Sorting conditions in standard Solr syntax . Integer start = 0 - Return the result at this position in the result set. If omitted, we will return the first result. Returns the SolrDocument of your query's first match, or null if there were no qualifying documents. SOLR Query, streaming matches Function mcrsolrstream(query) Submit a query to a Solr server and stream all the results incrementally, so they may be processed while the query is still active. You can cancel streaming queries before all results were transferred if it is convenient for you. Positional Parameters String query - The Solr query in standard Solr syntax . Optional Named Parameters Integer chunksize = 1000 - Size of each chunk that will be transferred vom server to client. HttpSolrClient client = MCRSolrClientFactory.mainSolrClient - The Solr client to use. If omitted, use MyCoRe's main client. String fl - Fields to return in standard Solr syntax Boolean parallel = false - If enabled, this function will return a parallel stream, which may allows for faster processing at the price of losing ordering information. Defaults to false , returning a sequential, ordered stream. String sort - Sorting conditions in standard Solr syntax . Returns a Stream<SolrDocument> containing your results. Interacting with Solr Documents Mixins for org.apache.solr.common.SolrDocument Because SolrDocument implements Java's Map interface, you get access to all of Groovy's convenience methods for Maps . Especially noteworthy are the following: solrdoc.field - Returns the value of the literal expression field contained in the Solr result SolrDocument solrdoc . Does not support field names containing special characters. solrdoc[field] - Returns the value of the String field contained in the Solr result SolrDocument solrdoc . This method also supports field names containing special characters. Examples: // find the ids of all MODS documents with \"Test\" in the title, recently modified documents first groovy:000> mcrsolrids(\"mods.title:*Test*\", sort:\"modified desc\") ===> [foo_mods_00000292, foo_mods_00000289, foo_mods_00000270, [...] // retrieve author names' of a single publication from the Solr server groovy:000> mcrsolrfirst(\"id:foo_mods_00000252\")[\"mods.name\"].join(\"; \") ===> Blaub\u00e4r, K\u00e4ptn; Bl\u00f6d, Hein // check for MyCoRe objects that exist in the Solr, but not the repository groovy:000> `mcrsolrstream(\"objectKind:mycoreobject\", fl: \"id\").map(x -> new MCRObjectID(x.id)) .filter(x -> !MCRXMLMetadataManager.instance().exists(x)).toList()` ===> []","title":"Solr Queries"},{"location":"mycore/#sessions-transactions-jobs","text":"The REPL's MyCoRe support functions handle sessions and transactions automatically for you. If you'd like to perform longer-running batch edits, or would like to interact directly with MyCoRe's classes within a session context, there are additional functions available that enable you to manage sessions yourself. Create a MyCoRe session Function mcrsession() Creates a new MyCoRe session without activating it. If invoked without parameters, it will return a default admin-level session which is associated with your current REPL session. Optional Named Parameters MCRSession session - Use this pre-existing session. String sessionid - Use the pre-existing session identified by this id. MCRUser user - Create a new session belonging to this user. String userid - Create a new session belonging to the user identified by this id. Returns the MCRSession you requested. Run code in a MyCoRe session / transaction Function mcrdo(closure) Executes a parameterless Groovy closure inside a MyCoRe session and optionally also a transaction. The session is transparently entered and left at entry and exit. The transaction will automatically be committed on success and rolled back if an exception is thrown. Positional Parameters Closure closure - The parameterless Groovy closure that will be executed. Optional Named Parameters Boolean join = false - Join the active outer session instead of creating a new one. In this case, this function will not release the session on exit. Boolean quiet = false - Silence the warning that is emitted when running with an active outer session and join = false . Boolean transaction = false - Create a new transaction and commit it on exit, or roll it back if an exception is thrown. You can additionally use all the named parameters of the mcrsession() function to control the session that will be created. Without any further parameters, the REPL's default admin session will be used. Returns the return value of your closure . Create a new job Function mcrjob(closure) This is a MyCoRe-enhanced version of the REPL's universal job() function . The major additional features that it provides are session- and transaction-management as well as integration with MyCoRe's processing infrastructure. You can view the progress of an mcrjob() in MyCoRe's web interface. Positional Parameters Closure closure - The closure to execute. See job() for details. Optional Named Parameters Boolean convert = false - Because the job's input parameter must be serializable, you can't use MCRObject , MCRDerivate or MCRMODSWrapper type objects as input. When this parameter is enabled, these types of objects will automatically be converted to JDOM's Document class, which can be used instead. Note that it is generally recommended to pass documents' IDs as inputs and not the documents itself. ThreadFactory threadfactory - This parameter analogous to its version in job() , with the added difference that mcrjob() uses it internally to manage MyCoRe session. You should refrain from setting it when using mcrjob() , or lose session and transaction handling features. Boolean transaction = false - Execute the job inside a MyCoRe transaction. It will be auto-committed if less than transactionerrors errors happened, or rolled back otherwise. Integer transactionerrors = 1 - If you set transaction , and the number of failed inputs reaches this limit, the entire job will be cancelled and the transaction rolled back. By default, this will happen on the first error. You can additionally use all the named parameters of the job() function as well as the the mcrsession() to tweak job processing and its MyCoRe session environment. If you do not specify any session parameters, your closure will run inside a newly created admin-level session. Returns the ReplJob that was created. Related Classes: REPLJob , REPLJobCallbackAutoTune provide additional functionality related to job control. Examples: // sessions can be nested groovy:000> mcrdo({ groovy:001> println(MCRSessionMgr.currentSession) groovy:002> mcrdo({ println(MCRSessionMgr.currentSession) }, userid: \"editor\", quiet: true) groovy:003> println(MCRSessionMgr.currentSession) groovy:004> }) MCRSession[c86a247f-ef95-4a20-853f-d27e9a935dc9,user:'administrator',ip:127.0.0.1] MCRSession[17a156c4-613c-4453-8ab7-71302a58bed0,user:'editor',ip:127.0.0.1] MCRSession[c86a247f-ef95-4a20-853f-d27e9a935dc9,user:'administrator',ip:127.0.0.1] // bulk editing in a transaction. for a speedup, try adding \"concurrency: 5\" to the parameters // THIS EXAMPLE WILL MAKE PERMANENT CHANGES TO YOUR DOCUMENTS groovy:000> ids = mcrsolrids(\"mods.title:*Test*\") ===> [foo_mods_00000272, foo_mods_00000273, foo_mods_00000274, [...] groovy:000> mcrjob({ id, job -> groovy:001> def doc = mcrxml(id) groovy:002> def title = doc[\"//mods:title\"] groovy:003> title << title.text.replaceAll(/(?i)Test/, \"Bork Bork Bork\") groovy:004> mcrsave(doc) groovy:005> return title.text groovy:006> }, inputs: ids, transaction: true, progress: true) ===> 20231017-125903-180455901 (Job 20231017-125903-180455901) [2023-10-17 12:59:03] INFO Job 20231017-125903-180455901: 4% done, eta 52s [...]","title":"Sessions, Transactions, Jobs"},{"location":"mycore/#mycores-native-cli","text":"MyCoRe's native CLI commands can be invoked from the REPL. Some of MyCoRe's CLI commands implicitly assume that there is only one CLI session active globally, so do not execute multiple commands in parallel (especially not in a parallelized job). Use MyCoRe's native CLI Function mcrcli(command) The REPL integrates MyCoRe's native CLI, which you can access from the SSH session. Please Note: Some of MyCoRe's CLI commands implicitly assume that there is only one CLI session active globally, so do not execute multiple commands in parallel (especially not in a parallelized job). Positional Parameters String command - The command to execute, exactly as you would type it in MyCoRe's native CLI. Optional Named Parameters Boolean errors_from_log = true - If enabled, log messages with the level ERROR or above will be treated as a failed CLI command. Many MyCoRe CLI commands do not throw exceptions when an error occurs, so this is necessary to detect failure conditions. MCRSession mcrsession = <the REPL's default admin session> - You can optionally specify a MyCoRe session that your command will run in. If omitted, the REPL's default administrator-level session will be used. Returns true if there were no errors, false if there were errors. Further details are available in the cauCLIResult MyCoRe session variable (access it e.g. by mcrsession().get(\"cauCLIResult\") ). Shell Command :mcrcli [command] :M [command] This is the shell command version of the mcrcli() function. It provides identical functionality, and is more convenient to work with since it does not require you to quote your command. Please Note: for technical reasons, repeated whitespace characters in your command string will be merged into a single space - even within quotes (which will be considered part of your command). If this is a problem, you should use the mcrcli() function instead. Returns true if there were no errors, false if there were errors. Further details are available in the cauCLIResult MyCoRe session variable (access it e.g. by mcrsession().get(\"cauCLIResult\") ). Examples: // let's select some documents groovy:000> :M select objects with solr query id:foo_mods_00000001 in core main Syntax matched (executed): select objects with solr query {0} in core {1} 1 objects selected CLI finished successfully: 1 commands Hint: retrieve detailed results from the \"cauCLIResult\" session variable, e.g.: mcrsession().get(\"cauCLIResult\") ===> true ===> true groovy:000> :M list selected Syntax matched (executed): list selected List selected MCRObjects foo_mods_00000001 CLI finished successfully: 1 commands Hint: retrieve detailed results from the \"cauCLIResult\" session variable, e.g.: mcrsession().get(\"cauCLIResult\") ===> true ===> true // let's now intentionally trigger an error groovy:000> :M set main file of invalid_id to foo Syntax matched (executed): set main file of {0} to {1} invalid_id is not valid. ERROR: Command 'set main file of invalid_id to foo' failed java.lang.RuntimeException: invalid_id is not valid. CLI finished with 1 errors Hint: retrieve detailed results from the \"cauCLIResult\" session variable, e.g.: mcrsession().get(\"cauCLIResult\") ERROR java.lang.RuntimeException: invalid_id is not valid. at groovysh_evaluate.mcrcli (groovysh_evaluate:31) at groovysh_evaluate.mcrcli (groovysh_evaluate) // we can retrieve detailed results from the session variable groovy:000> mcrsession().get(\"cauCLIResult\") ===> [[cmd:set main file of invalid_id to foo, log:Syntax matched (executed): set main file of {0} to {1} invalid_id is not valid. , error:java.lang.RuntimeException: invalid_id is not valid., timestamp:2023-10-10T11:19:39.861122497Z]]","title":"MyCoRe's native CLI"},{"location":"mycore/#compiling","text":"The REPL will normally compile your Groovy sources when the target application starts. If you want to compile code dynamically at runtime, there is a support function available for you. Compile Groovy sources Function mcrcompile(path) Compile the Groovy sources at the specified path and load them into a suitable classloader. This is a specialized version of the generic compile() function which will automatically use the proper ClassLoader and class path of your servlet container. Positional Parameters Path | File | String path - The location of the sources to compile. If you pass a directory, all .groovy files below it will be compiled as one coherent unit. Optional Named Parameters ClassLoader classloader = <MyCoRe's classloader> - The ClassLoader in which the generated classed should be put. Will default to MyCoRe's ClassLoader. String classpath = <MyCoRe's classpath> - The class path to use when locating targets of the @Patches annotation. Defaults to the MyCoRe's classpath. Returns the GroovySourceDirectory with the results of the compilation. Related Classes: GroovySourceDirectory provides additional functionality related to compilation.","title":"Compiling"},{"location":"repl/","text":"Using the REPL Once the REPL is started, simply connect to it with your SSH client. The foundation of cau-repl is Groovy's groovysh , so for the very basics you can refer to the groovysh Documentation . The general idea behind the REPL is that you can enter Groovy code, which is immediately executed in the same JVM as your target application. The results of your invocation are displayed to you after every single command and can be further modified with the next command you enter. This concept is known as a Read-Eval-Print Loop (REPL). All the classes the application uses internally are available to you, enriching it with full scripting capabilities. Basic Operation Apart from the normal Groovy syntax, the REPL provides a number of built-in commands. See the groovysh Command List . We will only focus on cau-repl specific additions in the following. Editing Files When you enter longer blocks of code - such as functions or loops - it is convenient to use a full-featured editor. cau-repl provides two commands for this. As a prerequisite, a suitable terminal-based editor must be installed on the system running cau-repl. By default, vim is configured. If you configure a different editor, make sure that it supports running without a TTY. Not all editor have this capability. Edit and evaluate a file Shell Command :editssh [filename] :E [filename] Opens an existing or new file named filename in an editor and immediately evaluates its content after returning to the REPL. Positional Parameters String filename optional - The name of the file to open Returns the return value of the last statement in the file. Edit a file without evaluating it Shell Command :editfilessh [filename] :EF [filename] Opens an existing or new file named filename in an editor without evaluating it in the REPL. Positional Parameters String filename optional - The name of the file to open Returns nothing. Examples: # invocation without a filename parameter # creates a temporary one-off file that is automatically deleted after evaluation groovy:000> :E # most convenient: invocation with a simple name - no path and no extension # creates / opens a persistent file named e.g. editbuffer-1.groovy in the REPL's workdir groovy:000> :E 1 # invocation with a full path creates / opens exactly this file groovy:000> :E /tmp/foo.groovy Logging The REPL has built-in logging functions that will make use of Log4J if it is installed, but also work without it. Log a message Function trace(...msgs) / debug(...msgs) / warn(...msgs) / error(...msgs) Logs the given message to suitable logging systems with the log-level corresponding to the method name. Positional Parameters - String msgs repeatable - The objects that will be logged after invoking their .toString() method. The first instance of this parameter is special in that it can contain {} placeholders. These will be replaced with the text representation of each succeeding further parameter. Excess parameters will be joined with a newline. Optional Named Parameters - ReplLog.LOG_TARGETS[] targets = REPLLog.DEFAULT_LOG_TARGETS - The list of targets that will receive this message. See the REPLLog documentation for possible values. If omitted, the message will be logged to Log4J if it is available or stderr if not. In addition, it will be written to the REPL's own logfile in its work directory. - PrintStream[] streams = [] - A list of multiple PrintStream that will receive this message. Empty by default. Returns The REPLLogEntry that was logged Retrieve the REPL log file Function repllog() Retrieves the contents of the REPL's internal log file, which is rotated every time the target application starts up. Returns a list of REPLLogEntry in chronological order. Retrieve the Tomcat log Function tomcatlog() Retrieves the contents of Tomcat's main catalina.out log file. This will only be successful, if you use Tomcat with a standard logging setup. Returns an array of String , in chronological order. Related Classes: REPLLog , REPLLogEntry provide additional functionality related to logging. Examples: // log a formatted message to sensible default targets groovy:000> info(\"Java version {} on {}/{}\", System.getProperty(\"java.version\"), System.getProperty(\"os.name\"), System.getProperty(\"os.arch\")) ===> [2023-09-28 12:33:58] INFO Java version 17.0.8 on Linux/amd64 // log a message to the REPL's log file and print it on all connected SSH sessions groovy:000> warn(\"restarting in 5min\", targets:[REPLLog.LOG_TARGETS.REPL_FILE, REPLLog.LOG_TARGETS.REPL_ALL_SHELLS]) ===> [2023-09-28 12:37:02] WARN restarting in 5min Job Management and Threads You can start long-running jobs in the REPL that will execute in the background and continue running after you end the SSH session. Jobs can be associated with a list of inputs to be processed. If you can list your inputs in advance, cau-repl can automatically parallelize your jobs. This also makes it possible to re-run just the inputs that failed later on, even after restarting the target application. Create a new job Function job(closure) Run the Groovy Closure closure in the background. You can optionally pass a list of input work items, which is then subsequently processed, tracking the job's progress in a file in the REPL's work directory. This makes it possible for you to resume aborted or failed executions as well as inspect the job's results even after restarting the target application. Jobs instances that throw an exception will be considered failed. Instances that do not throw an exception will be considered successful. MyCoRe users should use the mcrjob() function instead, which is additionally integrated with MyCoRe's job system. Positional Parameters Closure closure - The Groovy Closure to execute. If you do not specify the named parameter inputs , pass a closure that does not require any parameters ( { -> foo() } ). If you do specify inputs , pass a closure that accepts two parameters ( { x, j -> foo(x) } ). cau-repl will pass the current input in the first parameter and the job that it belongs to in the second parameter. The return value of the closure is considered the result of the job for the current input item. Return values' class must implement the Serializable interface, so cau-repl can persist your output. The results of each invocation of the closure are kept in memory, so design your jobs to return only small data structures. If you need to generate larger structures, you should persist them somewhere else yourself and only return a status code here. The ReplJob that is created by this call will by default be set as the closure's delegate , providing variants of the logging methods info() and so forth. This will cause your log messages to additionally be persisted in the job's state file, so you can review them via the ReplJob.jobLog() method. To signal a failure, throw any exception. Optional Named Parameters Boolean autostart = true - Controls whether your job should immediately be started or placed in the master job list in a paused state. Integer autotune experimental - If set, enables automatic parallelization for the processing of your input items. cau-repl will measure the throughput of work items and optimize the degree of parallelism on-the-fly. This works best when your work items are homogenous and individual processing time is small. The number you specify here is the maximum degree of parallelism you will allow. Note: to use a fixed number of parallel worker threads, just specify the concurrency parameter (see below) and don't set autotune . Boolean background = true - Controls whether this call should return immediately, or only after the job has finished running. You might want to disable background processing when you also enable progress messages. Boolean becomedelegate = true - Controls whether cau-repl will set the newly created ReplJob as your closure's delegate before executing it. This makes the instance methods of your ReplJob (especially the versions of the logging methods info() , etc. that also log to your job's private log) readily available for your closure. More information is available in Groovy's closure documentation . int concurrency = 1 - Spawn this many worker threads and process inputs in parallel. You can also change the concurrency level of a job while it is running. If you also pass the autotune parameter, the value of concurrency will be used as the initial concurrency level to start the tuning-process from. Boolean errorpause = false - If set, the job will be paused on the first error (i.e. when your closure throws an exception). If there are other parallel workers, the work items they are currently processing will not be aborted and your job will be fully paused after they too have finished their current work items. Collection<Serializable> inputs - The work items that will be sequentially - in the order you specified them - passed as the first parameter to subsequent executions of your closure. The entire list will be kept in memory, so only use small objects here. To process larger objects, pass their ids or addresses instead and fetch them yourself from your closure. If you omit this parameter, your closure will simply be called once without input arguments. String name = <job's key> - Set a descriptive name for your job to make identifying it easier. If omitted, your job's auto-generated key will also be used as its name. Boolean progress = false - Log job progress to the REPL periodically. Best combined with background = false . String resume - Pass the key of a finished ReplJob here to resume it. When you resume a job, your new job's state will be initialized from the persistent state file of the old job in the REPL's work directory. This includes inputs, results as well as its internal log. By default, only inputs that were not successfully processed (i.e. inputs that have failed, never started or started and did not finish at all) will be processed when you start the new job. Do not pass the inputs parameter when you resume - input values will automatically be read from the old job's state file. Boolean retryerror = true - When resuming a job, disable to not retry inputs that threw an exception. Boolean retrysuccess = false - When resuming a job, enable to also retry inputs that were successful. ThreadFactory threadfactory - Use a custom ThreadFactory to spawn the worker threads. If unspecified, the system default is used. Returns the ReplJob that was created. List current jobs Shell Command :job :J Prints a list of all jobs that were created in this session as well as their status. Returns The list in text format. Retrieve a current job and print its progress Shell Command :job [index|key] :J [index|key] Retrieves the ReplJob that has the given index number in the :J listing, or whose key matches the argument. Print its JobProgress to the console and return the job object. Returns The ReplJob that was requested. Pause or unpause a job Shell Command :job pause [index|key] / :job unpause [index|key] :J pause [index|key] / :J unpause [index|key] Pauses the job with the given key or index number in the :J listing. When paused, workers will finish their currently assigned work item, but will not receive any new work items. While residual items are still being processed, the job's state will be given as \"pausing\", after which it will transition to \"paused\". Unpausing a paused job will cause unprocessed work items to be submitted to the workers again. Returns when pausing: a boolean indicating if the job transitioned to the \"pausing\" state (could e.g. be false for already paused jobs); when unpausing: the number of milliseconds that the jobs has in the paused state. Cancel a job Shell Command :job cancel [index|key] / :job cancelforce [index|key] :J cancel [index|key] / :J cancelforce [index|key] Cancels the job with the given key or index number in the :J listing. No further input items will be passed to the worker threads. When invoked as cancel , previously active threads will be allowed to continue indefinitely until they have finished their previously assigned inputs. During this phase, the job state will be \"cancelling\" after which it will transition to \"cancelled\". The job is then ready for archiving or resuming it. When invoked as cancelforce , previously active threads will be forcefully terminated after a grace period of 10s. Jobs that don't have inputs can only be forcefully cancelled. Returns a boolean indicating if the job transitioned to the \"cancelling\" or \"cancelled\" state (could e.g. be false for jobs that finished in the meantime). Archive a job Shell Command :job archive [index|key] :J archive [index|key] Archives the finished job with the given key or index number in the :J listing, removing it from the job list and freeing its memory. Returns a boolean indicating if the job was archived or not. List all job keys, including archived jobs Shell Command :job archived :J archived Prints a list of all archived jobs' keys for which a state file in the REPL's work directory still exists. This excludes any currently loaded job. Returns The list in text format. Prune all successfully completed jobs, including archived jobs Shell Command :job prune :J prune Removes the state file of all jobs that have successfully completed (i.e. all inputs were processed without error) from the REPL's work directory. This includes both current and archived jobs. Returns The list of pruned keys in text format. List cau-repl's Threads Shell Command :ps :P Generates an overview of cau-repl's threads in the JVM. This includes shell sessions and job workers. The thread of your current REPL session will be marked with a * . Returns A textual representation of cau-repl's threads. List all JVM Threads Shell Command :ps all :P all Generates an overview of all threads in the JVM. The thread of your current REPL session will be marked with a * . Returns A textual representation of all threads in the JVM. Kill a Thread Shell Command :ps kill [...threadid] / :ps killforce [...threadid] :P kill [...threadid] / :P killforce [...threadid] Tries to terminate the threads with the given ids by invoking Thread.interrupt() on them. This does not guarantee termination in all cases, but can be helpful if you launched a misbehaving command in a different SSH session. Use killforce instead of kill for a more vigorous attempt at termination, which may or may not be successful. Don't use this command to cancel a job. Use :job cancel instead, which can handle cau-repl's job much better. Returns Nothing. Related Classes: ReplJob , REPLJobCallbackAutoTune provide additional functionality related to job control. Example: Simple Job // copy a file in a background job without parameters (please adjust filenames)... groovy:000> job({ return java.nio.file.Files.copy(java.nio.file.Path.of(\"/path/to/source\"), java.nio.file.Path.of(\"/path/to/destination\")) as String }) ===> 20231002-115717-998860232 (Job 20231002-115717-998860232) // ...now view the job's progress groovy:000> :J ===> [1] 20231002-115717-998860232 - Job 20231002-115717-998860232 - completed successfully (0/1 threads active), 100% Example: Parallel Job with Inputs // calculate primes around the 8th mersenne prime using a naive algorithm, 4 workers in parallel groovy:000> j = job({BigInteger x, j -> x > 1G && (x <= 3G || !(2G..x.sqrt()).find{ x.mod(it) == 0G })}, inputs:(2147000000G..2148000000G), concurrency:4) // monitor progress with the :J command (or run the job with \"progress: true\" to watch it in realtime) groovy:000> :J ===> [1] 20231002-143021-171027612 - Job 20231002-143021-171027612 - running (4/4 threads active), 7%, eta 2m // after the job is done, view the results groovy:000> j.results.findAll{ it.result }.collect{ j.inputs[it.index] } ===> [2147000041, 2147000081, 2147000111, 2147000117, 2147000173, 2147000189, 2147000243, 2147000281, 2147000293, [...] // now archive the job to free its memory groovy:000> :J archive 20231002-143021-17102761 groovy:000> j = null Example: Resuming // start the calculation again, cancelling and resuming it. disable status updates this time groovy:000> j = job({BigInteger x, j -> x > 1G && (x <= 3G || !(2G..x.sqrt()).find{ x.mod(it) == 0G })}, inputs:(2147000000G..2148000000G), concurrency:4) ===> 20231002-151111-065054552 (Job 20231002-151111-065054552) // wait a bit until the job is about half done, and then cancel it groovy:000> :J cancel 20231002-151111-065054552 ===> true // verify that the job's state is no longer \"cancelling\", but \"cancelled\" groovy:000> :J ===> [2] 20231002-151111-065054552 - Job 20231002-151111-065054552 - cancelled (0/4 threads active), 48% // you may now restart the target application (but you don't have to) [...] // let's resume our cancelled calculation, disabling autostart so we can inspect it's initial state groovy:000> j = job({BigInteger x, j -> x > 1G && (x <= 3G || !(2G..x.sqrt()).find{ x.mod(it) == 0G })}, resume:\"20231002-151111-065054552\", concurrency:4, autostart:false) ===> 20231002-151645-393465402 (Resume: Job 20231002-151111-065054552) // you can see that the \"success\" counter is at about 50%. results of the previous run were loaded groovy:000> j.progress ===> JobProgress[state=not yet started, nextInput=0, totalInputs=1000001, remainingInputs=1000001, success=480790, skippedSuccess=0, errors=0, skippedErrors=0, percentDone=0, pausedSince=null, cancelledSince=null, startTimestamp=null, doneTimestamp=null, eta=null, etaSeconds=null, activeThreads=0, future=null] groovy:000> j.results[0] ===> InputResult[key=20231002-151111-065054552, index=0, epochMicrosFrom=1696252271190601, epochMicrosTo=1696252271200158, result=false, error=null] // the job's private log - that you can write to with the info(),... methods from your closure - was also restored groovy:000> j.jobLog[0] ===> [2023-10-02 15:11:11] INFO Job 20231002-151111-065054552: Starting job... // resuming from where we cancelled groovy:000> j.start() ===> de.uni_kiel.rz.fdr.repl.REPLJob$1@4a183138[Not completed] // the first 50% of progress will pass very quickly, as the job skips all already completed inputs // now simply wait for the rest of the calculation to finish Loading Maven Artifacts You can load maven artifacts into the repl at runtime, without altering the installation of your target application. Load a maven artifact into the REPL Shell Command :grabrepl [group[:module[:version|*[:classifier]]]][@ext] :G [group[:module[:version|*[:classifier]]]][@ext] Fetches the maven artifact described by the parameters as well as its dependencies and loads it into the REPL for this session. Downloaded artifacts will be cached in the REPL's work directory to speed up the process in subsequent sessions. Specifying group , module and version is usually sufficient. Returns nothing. Examples: // fetch the apache-commons numbers module for primes and load it into the repl groovy:000> :G org.apache.commons:commons-numbers-primes // now import one of its classes groovy:000> import org.apache.commons.numbers.primes.Primes ===> [...], org.apache.commons.numbers.primes.Primes // and use it to find the prime factors of a number groovy:000> Primes.primeFactors(34592523) ===> [3, 7, 773, 2131] Compiling The REPL will normally compile your Groovy sources when the target application starts. If you want to compile code dynamically at runtime, there is a support function available for you. Compile Groovy sources Function compile(path) Compile the Groovy sources at the specified path and load them into a suitable classloader. MyCoRe user should use the mcrcompile() function instead, which will use default parameter values suitable for MyCoRe. Positional Parameters Path | File | String path - The location of the sources to compile. If you pass a directory, all .groovy files below it will be compiled as one coherent unit. Optional Named Parameters ClassLoader classloader = <REPL's classloader> - The ClassLoader in which the generated classed should be put. Will default to the REPL's ClassLoader, which is subject to the settings described in the Installation section. String classpath = <REPL's classpath> - The class path to use when locating targets of the @Patches annotation. Defaults to the REPL's classpath. Returns the GroovySourceDirectory with the results of the compilation. Related Classes: GroovySourceDirectory provides additional functionality related to compilation. Examples: // compile a single groovy class groovy:000> compile(\"Dummy.groovy\") ===> de.uni_kiel.rz.fdr.repl.groovy.GroovySourceDirectory@130807a5 // now import it to the REPL groovy:000> import foo.Dummy ===> [...], foo.Dummy groovy:000> x = new Dummy() ===> foo.Dummy@4cc38db Managing Breakpoints You can add breakpoints to your Groovy code. When triggered, they pause its execution and transfer control to the REPL. See the Extending section to start using this feature. Once you have augmented your code with breakpoints, you can manage them in the REPL: List currently triggered breakpoints and disabled patterns Shell Command :breakpoint :B Lists all currently triggered breakpoints: their numeric key, function and name. Will output a list of all currently disabled breakpoint patterns Returns the list in text format. Resume a currently triggered breakpoint Shell Command :breakpoint [key [feedback]] :B [key [feedback]] Resumes the currently triggered breakpoint with the specified key . You can optionally pass a feedback result, which will be returned as the result of the replbreakpoint function call that triggered this breakpoint. Please Note: for technical reasons, repeated whitespace characters in your feedback string will be merged into a single space - even within quotes (which will be considered part of your feedback). If this is a problem, you should use the REPLBreakpoint.resume() function instead. Returns nothing. Disable or enable breakpoints Shell Command :breakpoint disable [pattern] / :breakpoint enable [pattern] :B disable [pattern] / :B enable [pattern] Use this to disable or re-enable certain breakpoint matching a regular-expression pattern in Java RE syntax. A triggered breakpoint with a signature that matches one of your disabled patterns will be silently ignored. Your breakpoints' signatures are displayed in the :B breakpoint list after the numeric key (e.g. org.example.Dummy::foo - My Breakpoint ). Please Note: for technical reasons, repeated whitespace characters in your pattern string will be merged into a single space - even within quotes (which will be considered part of your pattern). If this is a problem, you should use the REPLBreakpoint.disable() / REPLBreakpoint.enable() functions instead. Returns nothing. Execute code in the thread of a triggered breakpoint Shell Command :breakpoint eval [key] [code] / :breakpoint eval [key] :B eval [key] [code] / :B eval [key] You can run code in the thread of a triggered breakpoint. Just pass the key of the target breakpoint and the Groovy code to run end it will execute. The environment executing your snippet will have the special variable this and also x set to the REPLBreakpoint instance that triggered. You know that your code has finished executed, when your breakpoint has a * marker in the :B list. You may now retrieve the result of you code using the eval [key] subcommand (i.e. without a code argument). Please Note: for technical reasons, repeated whitespace characters in your code string will be merged into a single space - even within quotes (which will be considered part of your code). If this is a problem, you should use the REPLBreakpoint.eval() function instead. Returns nothing when you submit code to run, or the results of your code wrapped in a REPLBreakpoint.EvalResult when you retrieve the result. Set the maximum number of concurrent breakpoints Shell Command :breakpoint max [limit] :B max [limit] Sets the global limit for the number of unresumed triggered breakpoint instances. The first time more than this many instances are triggered, a warning is logged and all further breakpoints are ignored (i.e. executed without interruption) until the total number on unresumed instances drops below this threshold. Set this to 0 to temporarily disable all breakpoints globally. Returns nothing. Related Classes: REPLBreakpoint provides additional functionality related to breakpoints. Examples: // you need a triggered breakpoint for this example. see the \"writing code\" section of the docs for further info. // list all triggered breakpoints groovy:000> :B ===> 0 org.example.Dummy::foo - My Breakpoint // let's evaluate some code in the breakpoint's context that returns its thread groovy:000> :B eval 0 Thread.currentThread() // note the asterisk \"*\", which signals that our code has returned a result groovy:000> :B ===> 0 org.example.Dummy::foo - My Breakpoint * // retrieve the result... groovy:000> :B eval 0 ===> EvalResult[result=Thread[GroovySh Client Thread: /127.0.0.1:57352,5,main], exception=null] // ...and save it to a variable groovy:000> t = _ // resume the breakpoint, passing a feedback string groovy:000> :B 0 some string data Hints Tab-completion and line history is available. When you mismatch parentheses or similar syntactic structures, the REPL may enter a state where it's waiting for you to properly syntactically finish your statement. To get out of this state, simply enter a single line consisting of just :c . The return value of your last command is always available in the special _ variable. This is useful to continue using it in the next line, or if you want to save it in a more persistent properly named variable. The stacktrace of a failed REPL command is available in the REPL's log. If you launch a mishbehaving command that blocks your REPL, start a second SSH session and use the :ps kill command to terminate it. groovysh's standard :edit / :e command is not very useful when accessing it via SSH, because it launches the editor in the TTY of the server process. Use the :editssh / :E commands instead to edit a file directly in your SSH session. groovysh's standard :grab / :g command does not use the correct classloader of the REPL. Use the :grabrepl / :G commands instead.","title":"Using the REPL"},{"location":"repl/#using-the-repl","text":"Once the REPL is started, simply connect to it with your SSH client. The foundation of cau-repl is Groovy's groovysh , so for the very basics you can refer to the groovysh Documentation . The general idea behind the REPL is that you can enter Groovy code, which is immediately executed in the same JVM as your target application. The results of your invocation are displayed to you after every single command and can be further modified with the next command you enter. This concept is known as a Read-Eval-Print Loop (REPL). All the classes the application uses internally are available to you, enriching it with full scripting capabilities.","title":"Using the REPL"},{"location":"repl/#basic-operation","text":"Apart from the normal Groovy syntax, the REPL provides a number of built-in commands. See the groovysh Command List . We will only focus on cau-repl specific additions in the following.","title":"Basic Operation"},{"location":"repl/#editing-files","text":"When you enter longer blocks of code - such as functions or loops - it is convenient to use a full-featured editor. cau-repl provides two commands for this. As a prerequisite, a suitable terminal-based editor must be installed on the system running cau-repl. By default, vim is configured. If you configure a different editor, make sure that it supports running without a TTY. Not all editor have this capability. Edit and evaluate a file Shell Command :editssh [filename] :E [filename] Opens an existing or new file named filename in an editor and immediately evaluates its content after returning to the REPL. Positional Parameters String filename optional - The name of the file to open Returns the return value of the last statement in the file. Edit a file without evaluating it Shell Command :editfilessh [filename] :EF [filename] Opens an existing or new file named filename in an editor without evaluating it in the REPL. Positional Parameters String filename optional - The name of the file to open Returns nothing. Examples: # invocation without a filename parameter # creates a temporary one-off file that is automatically deleted after evaluation groovy:000> :E # most convenient: invocation with a simple name - no path and no extension # creates / opens a persistent file named e.g. editbuffer-1.groovy in the REPL's workdir groovy:000> :E 1 # invocation with a full path creates / opens exactly this file groovy:000> :E /tmp/foo.groovy","title":"Editing Files"},{"location":"repl/#logging","text":"The REPL has built-in logging functions that will make use of Log4J if it is installed, but also work without it. Log a message Function trace(...msgs) / debug(...msgs) / warn(...msgs) / error(...msgs) Logs the given message to suitable logging systems with the log-level corresponding to the method name. Positional Parameters - String msgs repeatable - The objects that will be logged after invoking their .toString() method. The first instance of this parameter is special in that it can contain {} placeholders. These will be replaced with the text representation of each succeeding further parameter. Excess parameters will be joined with a newline. Optional Named Parameters - ReplLog.LOG_TARGETS[] targets = REPLLog.DEFAULT_LOG_TARGETS - The list of targets that will receive this message. See the REPLLog documentation for possible values. If omitted, the message will be logged to Log4J if it is available or stderr if not. In addition, it will be written to the REPL's own logfile in its work directory. - PrintStream[] streams = [] - A list of multiple PrintStream that will receive this message. Empty by default. Returns The REPLLogEntry that was logged Retrieve the REPL log file Function repllog() Retrieves the contents of the REPL's internal log file, which is rotated every time the target application starts up. Returns a list of REPLLogEntry in chronological order. Retrieve the Tomcat log Function tomcatlog() Retrieves the contents of Tomcat's main catalina.out log file. This will only be successful, if you use Tomcat with a standard logging setup. Returns an array of String , in chronological order. Related Classes: REPLLog , REPLLogEntry provide additional functionality related to logging. Examples: // log a formatted message to sensible default targets groovy:000> info(\"Java version {} on {}/{}\", System.getProperty(\"java.version\"), System.getProperty(\"os.name\"), System.getProperty(\"os.arch\")) ===> [2023-09-28 12:33:58] INFO Java version 17.0.8 on Linux/amd64 // log a message to the REPL's log file and print it on all connected SSH sessions groovy:000> warn(\"restarting in 5min\", targets:[REPLLog.LOG_TARGETS.REPL_FILE, REPLLog.LOG_TARGETS.REPL_ALL_SHELLS]) ===> [2023-09-28 12:37:02] WARN restarting in 5min","title":"Logging"},{"location":"repl/#job-management-and-threads","text":"You can start long-running jobs in the REPL that will execute in the background and continue running after you end the SSH session. Jobs can be associated with a list of inputs to be processed. If you can list your inputs in advance, cau-repl can automatically parallelize your jobs. This also makes it possible to re-run just the inputs that failed later on, even after restarting the target application. Create a new job Function job(closure) Run the Groovy Closure closure in the background. You can optionally pass a list of input work items, which is then subsequently processed, tracking the job's progress in a file in the REPL's work directory. This makes it possible for you to resume aborted or failed executions as well as inspect the job's results even after restarting the target application. Jobs instances that throw an exception will be considered failed. Instances that do not throw an exception will be considered successful. MyCoRe users should use the mcrjob() function instead, which is additionally integrated with MyCoRe's job system. Positional Parameters Closure closure - The Groovy Closure to execute. If you do not specify the named parameter inputs , pass a closure that does not require any parameters ( { -> foo() } ). If you do specify inputs , pass a closure that accepts two parameters ( { x, j -> foo(x) } ). cau-repl will pass the current input in the first parameter and the job that it belongs to in the second parameter. The return value of the closure is considered the result of the job for the current input item. Return values' class must implement the Serializable interface, so cau-repl can persist your output. The results of each invocation of the closure are kept in memory, so design your jobs to return only small data structures. If you need to generate larger structures, you should persist them somewhere else yourself and only return a status code here. The ReplJob that is created by this call will by default be set as the closure's delegate , providing variants of the logging methods info() and so forth. This will cause your log messages to additionally be persisted in the job's state file, so you can review them via the ReplJob.jobLog() method. To signal a failure, throw any exception. Optional Named Parameters Boolean autostart = true - Controls whether your job should immediately be started or placed in the master job list in a paused state. Integer autotune experimental - If set, enables automatic parallelization for the processing of your input items. cau-repl will measure the throughput of work items and optimize the degree of parallelism on-the-fly. This works best when your work items are homogenous and individual processing time is small. The number you specify here is the maximum degree of parallelism you will allow. Note: to use a fixed number of parallel worker threads, just specify the concurrency parameter (see below) and don't set autotune . Boolean background = true - Controls whether this call should return immediately, or only after the job has finished running. You might want to disable background processing when you also enable progress messages. Boolean becomedelegate = true - Controls whether cau-repl will set the newly created ReplJob as your closure's delegate before executing it. This makes the instance methods of your ReplJob (especially the versions of the logging methods info() , etc. that also log to your job's private log) readily available for your closure. More information is available in Groovy's closure documentation . int concurrency = 1 - Spawn this many worker threads and process inputs in parallel. You can also change the concurrency level of a job while it is running. If you also pass the autotune parameter, the value of concurrency will be used as the initial concurrency level to start the tuning-process from. Boolean errorpause = false - If set, the job will be paused on the first error (i.e. when your closure throws an exception). If there are other parallel workers, the work items they are currently processing will not be aborted and your job will be fully paused after they too have finished their current work items. Collection<Serializable> inputs - The work items that will be sequentially - in the order you specified them - passed as the first parameter to subsequent executions of your closure. The entire list will be kept in memory, so only use small objects here. To process larger objects, pass their ids or addresses instead and fetch them yourself from your closure. If you omit this parameter, your closure will simply be called once without input arguments. String name = <job's key> - Set a descriptive name for your job to make identifying it easier. If omitted, your job's auto-generated key will also be used as its name. Boolean progress = false - Log job progress to the REPL periodically. Best combined with background = false . String resume - Pass the key of a finished ReplJob here to resume it. When you resume a job, your new job's state will be initialized from the persistent state file of the old job in the REPL's work directory. This includes inputs, results as well as its internal log. By default, only inputs that were not successfully processed (i.e. inputs that have failed, never started or started and did not finish at all) will be processed when you start the new job. Do not pass the inputs parameter when you resume - input values will automatically be read from the old job's state file. Boolean retryerror = true - When resuming a job, disable to not retry inputs that threw an exception. Boolean retrysuccess = false - When resuming a job, enable to also retry inputs that were successful. ThreadFactory threadfactory - Use a custom ThreadFactory to spawn the worker threads. If unspecified, the system default is used. Returns the ReplJob that was created. List current jobs Shell Command :job :J Prints a list of all jobs that were created in this session as well as their status. Returns The list in text format. Retrieve a current job and print its progress Shell Command :job [index|key] :J [index|key] Retrieves the ReplJob that has the given index number in the :J listing, or whose key matches the argument. Print its JobProgress to the console and return the job object. Returns The ReplJob that was requested. Pause or unpause a job Shell Command :job pause [index|key] / :job unpause [index|key] :J pause [index|key] / :J unpause [index|key] Pauses the job with the given key or index number in the :J listing. When paused, workers will finish their currently assigned work item, but will not receive any new work items. While residual items are still being processed, the job's state will be given as \"pausing\", after which it will transition to \"paused\". Unpausing a paused job will cause unprocessed work items to be submitted to the workers again. Returns when pausing: a boolean indicating if the job transitioned to the \"pausing\" state (could e.g. be false for already paused jobs); when unpausing: the number of milliseconds that the jobs has in the paused state. Cancel a job Shell Command :job cancel [index|key] / :job cancelforce [index|key] :J cancel [index|key] / :J cancelforce [index|key] Cancels the job with the given key or index number in the :J listing. No further input items will be passed to the worker threads. When invoked as cancel , previously active threads will be allowed to continue indefinitely until they have finished their previously assigned inputs. During this phase, the job state will be \"cancelling\" after which it will transition to \"cancelled\". The job is then ready for archiving or resuming it. When invoked as cancelforce , previously active threads will be forcefully terminated after a grace period of 10s. Jobs that don't have inputs can only be forcefully cancelled. Returns a boolean indicating if the job transitioned to the \"cancelling\" or \"cancelled\" state (could e.g. be false for jobs that finished in the meantime). Archive a job Shell Command :job archive [index|key] :J archive [index|key] Archives the finished job with the given key or index number in the :J listing, removing it from the job list and freeing its memory. Returns a boolean indicating if the job was archived or not. List all job keys, including archived jobs Shell Command :job archived :J archived Prints a list of all archived jobs' keys for which a state file in the REPL's work directory still exists. This excludes any currently loaded job. Returns The list in text format. Prune all successfully completed jobs, including archived jobs Shell Command :job prune :J prune Removes the state file of all jobs that have successfully completed (i.e. all inputs were processed without error) from the REPL's work directory. This includes both current and archived jobs. Returns The list of pruned keys in text format. List cau-repl's Threads Shell Command :ps :P Generates an overview of cau-repl's threads in the JVM. This includes shell sessions and job workers. The thread of your current REPL session will be marked with a * . Returns A textual representation of cau-repl's threads. List all JVM Threads Shell Command :ps all :P all Generates an overview of all threads in the JVM. The thread of your current REPL session will be marked with a * . Returns A textual representation of all threads in the JVM. Kill a Thread Shell Command :ps kill [...threadid] / :ps killforce [...threadid] :P kill [...threadid] / :P killforce [...threadid] Tries to terminate the threads with the given ids by invoking Thread.interrupt() on them. This does not guarantee termination in all cases, but can be helpful if you launched a misbehaving command in a different SSH session. Use killforce instead of kill for a more vigorous attempt at termination, which may or may not be successful. Don't use this command to cancel a job. Use :job cancel instead, which can handle cau-repl's job much better. Returns Nothing. Related Classes: ReplJob , REPLJobCallbackAutoTune provide additional functionality related to job control. Example: Simple Job // copy a file in a background job without parameters (please adjust filenames)... groovy:000> job({ return java.nio.file.Files.copy(java.nio.file.Path.of(\"/path/to/source\"), java.nio.file.Path.of(\"/path/to/destination\")) as String }) ===> 20231002-115717-998860232 (Job 20231002-115717-998860232) // ...now view the job's progress groovy:000> :J ===> [1] 20231002-115717-998860232 - Job 20231002-115717-998860232 - completed successfully (0/1 threads active), 100% Example: Parallel Job with Inputs // calculate primes around the 8th mersenne prime using a naive algorithm, 4 workers in parallel groovy:000> j = job({BigInteger x, j -> x > 1G && (x <= 3G || !(2G..x.sqrt()).find{ x.mod(it) == 0G })}, inputs:(2147000000G..2148000000G), concurrency:4) // monitor progress with the :J command (or run the job with \"progress: true\" to watch it in realtime) groovy:000> :J ===> [1] 20231002-143021-171027612 - Job 20231002-143021-171027612 - running (4/4 threads active), 7%, eta 2m // after the job is done, view the results groovy:000> j.results.findAll{ it.result }.collect{ j.inputs[it.index] } ===> [2147000041, 2147000081, 2147000111, 2147000117, 2147000173, 2147000189, 2147000243, 2147000281, 2147000293, [...] // now archive the job to free its memory groovy:000> :J archive 20231002-143021-17102761 groovy:000> j = null Example: Resuming // start the calculation again, cancelling and resuming it. disable status updates this time groovy:000> j = job({BigInteger x, j -> x > 1G && (x <= 3G || !(2G..x.sqrt()).find{ x.mod(it) == 0G })}, inputs:(2147000000G..2148000000G), concurrency:4) ===> 20231002-151111-065054552 (Job 20231002-151111-065054552) // wait a bit until the job is about half done, and then cancel it groovy:000> :J cancel 20231002-151111-065054552 ===> true // verify that the job's state is no longer \"cancelling\", but \"cancelled\" groovy:000> :J ===> [2] 20231002-151111-065054552 - Job 20231002-151111-065054552 - cancelled (0/4 threads active), 48% // you may now restart the target application (but you don't have to) [...] // let's resume our cancelled calculation, disabling autostart so we can inspect it's initial state groovy:000> j = job({BigInteger x, j -> x > 1G && (x <= 3G || !(2G..x.sqrt()).find{ x.mod(it) == 0G })}, resume:\"20231002-151111-065054552\", concurrency:4, autostart:false) ===> 20231002-151645-393465402 (Resume: Job 20231002-151111-065054552) // you can see that the \"success\" counter is at about 50%. results of the previous run were loaded groovy:000> j.progress ===> JobProgress[state=not yet started, nextInput=0, totalInputs=1000001, remainingInputs=1000001, success=480790, skippedSuccess=0, errors=0, skippedErrors=0, percentDone=0, pausedSince=null, cancelledSince=null, startTimestamp=null, doneTimestamp=null, eta=null, etaSeconds=null, activeThreads=0, future=null] groovy:000> j.results[0] ===> InputResult[key=20231002-151111-065054552, index=0, epochMicrosFrom=1696252271190601, epochMicrosTo=1696252271200158, result=false, error=null] // the job's private log - that you can write to with the info(),... methods from your closure - was also restored groovy:000> j.jobLog[0] ===> [2023-10-02 15:11:11] INFO Job 20231002-151111-065054552: Starting job... // resuming from where we cancelled groovy:000> j.start() ===> de.uni_kiel.rz.fdr.repl.REPLJob$1@4a183138[Not completed] // the first 50% of progress will pass very quickly, as the job skips all already completed inputs // now simply wait for the rest of the calculation to finish","title":"Job Management and Threads"},{"location":"repl/#loading-maven-artifacts","text":"You can load maven artifacts into the repl at runtime, without altering the installation of your target application. Load a maven artifact into the REPL Shell Command :grabrepl [group[:module[:version|*[:classifier]]]][@ext] :G [group[:module[:version|*[:classifier]]]][@ext] Fetches the maven artifact described by the parameters as well as its dependencies and loads it into the REPL for this session. Downloaded artifacts will be cached in the REPL's work directory to speed up the process in subsequent sessions. Specifying group , module and version is usually sufficient. Returns nothing. Examples: // fetch the apache-commons numbers module for primes and load it into the repl groovy:000> :G org.apache.commons:commons-numbers-primes // now import one of its classes groovy:000> import org.apache.commons.numbers.primes.Primes ===> [...], org.apache.commons.numbers.primes.Primes // and use it to find the prime factors of a number groovy:000> Primes.primeFactors(34592523) ===> [3, 7, 773, 2131]","title":"Loading Maven Artifacts"},{"location":"repl/#compiling","text":"The REPL will normally compile your Groovy sources when the target application starts. If you want to compile code dynamically at runtime, there is a support function available for you. Compile Groovy sources Function compile(path) Compile the Groovy sources at the specified path and load them into a suitable classloader. MyCoRe user should use the mcrcompile() function instead, which will use default parameter values suitable for MyCoRe. Positional Parameters Path | File | String path - The location of the sources to compile. If you pass a directory, all .groovy files below it will be compiled as one coherent unit. Optional Named Parameters ClassLoader classloader = <REPL's classloader> - The ClassLoader in which the generated classed should be put. Will default to the REPL's ClassLoader, which is subject to the settings described in the Installation section. String classpath = <REPL's classpath> - The class path to use when locating targets of the @Patches annotation. Defaults to the REPL's classpath. Returns the GroovySourceDirectory with the results of the compilation. Related Classes: GroovySourceDirectory provides additional functionality related to compilation. Examples: // compile a single groovy class groovy:000> compile(\"Dummy.groovy\") ===> de.uni_kiel.rz.fdr.repl.groovy.GroovySourceDirectory@130807a5 // now import it to the REPL groovy:000> import foo.Dummy ===> [...], foo.Dummy groovy:000> x = new Dummy() ===> foo.Dummy@4cc38db","title":"Compiling"},{"location":"repl/#managing-breakpoints","text":"You can add breakpoints to your Groovy code. When triggered, they pause its execution and transfer control to the REPL. See the Extending section to start using this feature. Once you have augmented your code with breakpoints, you can manage them in the REPL: List currently triggered breakpoints and disabled patterns Shell Command :breakpoint :B Lists all currently triggered breakpoints: their numeric key, function and name. Will output a list of all currently disabled breakpoint patterns Returns the list in text format. Resume a currently triggered breakpoint Shell Command :breakpoint [key [feedback]] :B [key [feedback]] Resumes the currently triggered breakpoint with the specified key . You can optionally pass a feedback result, which will be returned as the result of the replbreakpoint function call that triggered this breakpoint. Please Note: for technical reasons, repeated whitespace characters in your feedback string will be merged into a single space - even within quotes (which will be considered part of your feedback). If this is a problem, you should use the REPLBreakpoint.resume() function instead. Returns nothing. Disable or enable breakpoints Shell Command :breakpoint disable [pattern] / :breakpoint enable [pattern] :B disable [pattern] / :B enable [pattern] Use this to disable or re-enable certain breakpoint matching a regular-expression pattern in Java RE syntax. A triggered breakpoint with a signature that matches one of your disabled patterns will be silently ignored. Your breakpoints' signatures are displayed in the :B breakpoint list after the numeric key (e.g. org.example.Dummy::foo - My Breakpoint ). Please Note: for technical reasons, repeated whitespace characters in your pattern string will be merged into a single space - even within quotes (which will be considered part of your pattern). If this is a problem, you should use the REPLBreakpoint.disable() / REPLBreakpoint.enable() functions instead. Returns nothing. Execute code in the thread of a triggered breakpoint Shell Command :breakpoint eval [key] [code] / :breakpoint eval [key] :B eval [key] [code] / :B eval [key] You can run code in the thread of a triggered breakpoint. Just pass the key of the target breakpoint and the Groovy code to run end it will execute. The environment executing your snippet will have the special variable this and also x set to the REPLBreakpoint instance that triggered. You know that your code has finished executed, when your breakpoint has a * marker in the :B list. You may now retrieve the result of you code using the eval [key] subcommand (i.e. without a code argument). Please Note: for technical reasons, repeated whitespace characters in your code string will be merged into a single space - even within quotes (which will be considered part of your code). If this is a problem, you should use the REPLBreakpoint.eval() function instead. Returns nothing when you submit code to run, or the results of your code wrapped in a REPLBreakpoint.EvalResult when you retrieve the result. Set the maximum number of concurrent breakpoints Shell Command :breakpoint max [limit] :B max [limit] Sets the global limit for the number of unresumed triggered breakpoint instances. The first time more than this many instances are triggered, a warning is logged and all further breakpoints are ignored (i.e. executed without interruption) until the total number on unresumed instances drops below this threshold. Set this to 0 to temporarily disable all breakpoints globally. Returns nothing. Related Classes: REPLBreakpoint provides additional functionality related to breakpoints. Examples: // you need a triggered breakpoint for this example. see the \"writing code\" section of the docs for further info. // list all triggered breakpoints groovy:000> :B ===> 0 org.example.Dummy::foo - My Breakpoint // let's evaluate some code in the breakpoint's context that returns its thread groovy:000> :B eval 0 Thread.currentThread() // note the asterisk \"*\", which signals that our code has returned a result groovy:000> :B ===> 0 org.example.Dummy::foo - My Breakpoint * // retrieve the result... groovy:000> :B eval 0 ===> EvalResult[result=Thread[GroovySh Client Thread: /127.0.0.1:57352,5,main], exception=null] // ...and save it to a variable groovy:000> t = _ // resume the breakpoint, passing a feedback string groovy:000> :B 0 some string data","title":"Managing Breakpoints"},{"location":"repl/#hints","text":"Tab-completion and line history is available. When you mismatch parentheses or similar syntactic structures, the REPL may enter a state where it's waiting for you to properly syntactically finish your statement. To get out of this state, simply enter a single line consisting of just :c . The return value of your last command is always available in the special _ variable. This is useful to continue using it in the next line, or if you want to save it in a more persistent properly named variable. The stacktrace of a failed REPL command is available in the REPL's log. If you launch a mishbehaving command that blocks your REPL, start a second SSH session and use the :ps kill command to terminate it. groovysh's standard :edit / :e command is not very useful when accessing it via SSH, because it launches the editor in the TTY of the server process. Use the :editssh / :E commands instead to edit a file directly in your SSH session. groovysh's standard :grab / :g command does not use the correct classloader of the REPL. Use the :grabrepl / :G commands instead.","title":"Hints"},{"location":"apidocs/legal/jquery/","text":"jQuery v3.6.1 jQuery License jQuery v 3.6.1 Copyright OpenJS Foundation and other contributors, https://openjsf.org/ Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. ****************************************** The jQuery JavaScript Library v3.6.1 also includes Sizzle.js Sizzle.js includes the following license: Copyright JS Foundation and other contributors, https://js.foundation/ This software consists of voluntary contributions made by many individuals. For exact contribution history, see the revision history available at https://github.com/jquery/sizzle The following license applies to all parts of this software except as documented below: ==== Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. ==== All files located in the node_modules and external directories are externally maintained libraries used by this software which have their own licenses; we recommend you read them, as their terms may differ from the terms above. *********************","title":"Jquery"},{"location":"apidocs/legal/jquery/#jquery-v361","text":"","title":"jQuery v3.6.1"},{"location":"apidocs/legal/jquery/#jquery-license","text":"jQuery v 3.6.1 Copyright OpenJS Foundation and other contributors, https://openjsf.org/ Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. ****************************************** The jQuery JavaScript Library v3.6.1 also includes Sizzle.js Sizzle.js includes the following license: Copyright JS Foundation and other contributors, https://js.foundation/ This software consists of voluntary contributions made by many individuals. For exact contribution history, see the revision history available at https://github.com/jquery/sizzle The following license applies to all parts of this software except as documented below: ==== Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. ==== All files located in the node_modules and external directories are externally maintained libraries used by this software which have their own licenses; we recommend you read them, as their terms may differ from the terms above. *********************","title":"jQuery License"},{"location":"apidocs/legal/jqueryUI/","text":"jQuery UI v1.13.2 jQuery UI License Copyright jQuery Foundation and other contributors, https://jquery.org/ This software consists of voluntary contributions made by many individuals. For exact contribution history, see the revision history available at https://github.com/jquery/jquery-ui The following license applies to all parts of this software except as documented below: ==== Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. ==== Copyright and related rights for sample code are waived via CC0. Sample code is defined as all source code contained within the demos directory. CC0: http://creativecommons.org/publicdomain/zero/1.0/ ==== All files located in the node_modules and external directories are externally maintained libraries used by this software which have their own licenses; we recommend you read them, as their terms may differ from the terms above.","title":"jqueryUI"},{"location":"apidocs/legal/jqueryUI/#jquery-ui-v1132","text":"","title":"jQuery UI v1.13.2"},{"location":"apidocs/legal/jqueryUI/#jquery-ui-license","text":"Copyright jQuery Foundation and other contributors, https://jquery.org/ This software consists of voluntary contributions made by many individuals. For exact contribution history, see the revision history available at https://github.com/jquery/jquery-ui The following license applies to all parts of this software except as documented below: ==== Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. ==== Copyright and related rights for sample code are waived via CC0. Sample code is defined as all source code contained within the demos directory. CC0: http://creativecommons.org/publicdomain/zero/1.0/ ==== All files located in the node_modules and external directories are externally maintained libraries used by this software which have their own licenses; we recommend you read them, as their terms may differ from the terms above.","title":"jQuery UI License"}]}